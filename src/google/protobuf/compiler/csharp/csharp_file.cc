// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.
// http://code.google.com/p/protobuf/
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Author: jonskeet@google.com (Jon Skeet)
//  Following the Java generator by kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.

#include <google/protobuf/compiler/csharp/csharp_file.h>
#include <google/protobuf/compiler/csharp/csharp_enum.h>
#include <google/protobuf/compiler/csharp/csharp_service.h>
#include <google/protobuf/compiler/csharp/csharp_extension.h>
#include <google/protobuf/compiler/csharp/csharp_helpers.h>
#include <google/protobuf/compiler/csharp/csharp_message.h>
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/stubs/strutil.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace csharp {

FileGenerator::FileGenerator(const FileDescriptor* file)
  : file_(file),
    csharp_namespace_(FileCSharpNamespace(file)),
    classname_(FileClassName(file)) {}

FileGenerator::~FileGenerator() {}

bool FileGenerator::Validate(string* error) {
  // Check that no class name matches the file's class name.  This is a common
  // problem that leads to Java compile errors that can be hard to understand.
  // It's especially bad when using the csharp_multiple_files, since we would
  // end up overwriting the outer class with one of the inner ones.

  bool found_conflict = false;
  for (int i = 0; i < file_->enum_type_count() && !found_conflict; i++) {
    if (file_->enum_type(i)->name() == classname_) {
      found_conflict = true;
    }
  }
  for (int i = 0; i < file_->message_type_count() && !found_conflict; i++) {
    if (file_->message_type(i)->name() == classname_) {
      found_conflict = true;
    }
  }
  for (int i = 0; i < file_->service_count() && !found_conflict; i++) {
    if (file_->service(i)->name() == classname_) {
      found_conflict = true;
    }
  }

  if (found_conflict) {
    error->assign(file_->name());
    error->append(
      ": Cannot generate C# output because the file's top-level class name, \"");
    error->append(classname_);
    error->append(
      "\", matches the name of one of the message, service or enum types. "
      "Please either rename the type or use the csharp_file_classname "
      "option to specify a different file-level class name for the .proto file.");
    return false;
  }

  return true;
}

void FileGenerator::Generate(io::Printer* printer) {
  // We don't import anything because we refer to all classes by their
  // fully-qualified names in the generated source.
  printer->Print(
    "// Generated by the protocol buffer compiler.  DO NOT EDIT!\r\n"
    "\r\n");

  // Namespace aliases to avoid lines getting horribly long
  printer->Print("using pb = global::Google.ProtocolBuffers;\r\n");
  printer->Print("using pbc = global::Google.ProtocolBuffers.Collections;\r\n");
  printer->Print("using pbd = global::Google.ProtocolBuffers.Descriptors;\r\n");
  printer->Print("using scg = global::System.Collections.Generic;\r\n");

  if (!csharp_namespace_.empty()) {
    printer->Print(
      "namespace $namespace$ {\r\n",
      "namespace", csharp_namespace_);
    printer->Indent();
  }
  printer->Print("\r\n");
  printer->Print(
    "$access$ static partial class $classname$ {\r\n\r\n",
    "classname", classname_,
    "access", ClassAccessLevel(file_));
  printer->Indent();

  // -----------------------------------------------------------------

  printer->Print("#region Descriptor\r\n");
  // Embed the descriptor.  We simply serialize the entire FileDescriptorProto
  // and embed it as a byte array, which is parsed and built into real
  // descriptors at initialization time.
  FileDescriptorProto file_proto;
  file_->CopyTo(&file_proto);
  string file_data;
  file_proto.SerializeToString(&file_data);

  printer->Print(
    "public static pbd::FileDescriptor Descriptor {\r\n"
    "    get { return descriptor; }\r\n"
    "}\r\n"
    "private static readonly pbd::FileDescriptor descriptor = pbd::FileDescriptor.InternalBuildGeneratedFileFrom (\r\n"
    "    new byte[] {");
  printer->Indent();
  printer->Indent();
  printer->Indent();
  printer->Indent();

  // Only write 20 bytes per line.
  static const int kBytesPerLine = 20;
  char buffer[3];
  for (int i = 0; i < file_data.size(); i++) {
    if ((i % kBytesPerLine) == 0) {
      printer->Print("\r\n");
    }

    // TODO(jonskeet): There must be a better way of doing this!
    sprintf(buffer, "%02x", static_cast<uint8>(file_data[i]));
    printer->Print("0x$val$, ", "val", buffer);
  }
  printer->Outdent();
  printer->Outdent();
  printer->Print("\r\n}, new pbd::FileDescriptor[] {\r\n");
  for (int i = 0; i < file_->dependency_count(); i++) {
    printer->Print(
      "        $dependency$.Descriptor,\r\n",
      "dependency", ClassName(file_->dependency(i)));
  }

  printer->Print("});\r\n");

  printer->Outdent();
  printer->Outdent();
  printer->Print("#endregion\r\n\r\n");

  // -----------------------------------------------------------------



  // Extensions must be generated in the outer class since they are values,
  // not classes.
  printer->Print("#region Extensions\r\n");
  for (int i = 0; i < file_->extension_count(); i++) {
    ExtensionGenerator(file_->extension(i)).Generate(printer);
  }
  printer->Print("#endregion\r\n\r\n");

  printer->Print("#region Static variables\r\n");
  // Static variables.
  for (int i = 0; i < file_->message_type_count(); i++) {
    // TODO(kenton):  Reuse MessageGenerator objects?
    MessageGenerator(file_->message_type(i)).GenerateStaticVariables(printer);
  }
  printer->Print("#endregion\r\n\r\n");

  // If we're not nesting classes, the class for the .proto file is done now
  if (!file_->options().csharp_nest_classes()) {
    printer->Outdent();
    printer->Print("}\r\n\r\n");
  }

  if (!file_->options().csharp_multiple_files()) {
    printer->Print("#region Enums\r\n");
    for (int i = 0; i < file_->enum_type_count(); i++) {
      EnumGenerator(file_->enum_type(i)).Generate(printer);
    }
    printer->Print("#endregion\r\n\r\n");
    printer->Print("#region Messages\r\n");
    for (int i = 0; i < file_->message_type_count(); i++) {
      MessageGenerator(file_->message_type(i)).Generate(printer);
    }
    printer->Print("#endregion\r\n\r\n");
    printer->Print("#region Services\r\n");
    for (int i = 0; i < file_->service_count(); i++) {
      ServiceGenerator(file_->service(i)).Generate(printer);
    }
    printer->Print("#endregion\r\n");
  }

  // If we were nesting classes, we still need to finish the outer one at some point!
  if (file_->options().csharp_nest_classes()) {
    printer->Outdent();
    printer->Print("}\r\n\r\n");
  }

  if (!csharp_namespace_.empty()) {
    printer->Outdent();
    printer->Print("}\r\n");
  }
}

template<typename GeneratorClass, typename DescriptorClass>
static void GenerateSibling(const string& csharp_namespace,
                            const FileDescriptor* file,
                            const DescriptorClass* descriptor,
                            OutputDirectory* output_directory,
                            vector<string>* file_list) {
  string filename = descriptor->name() + ".cs";
  file_list->push_back(filename);

  scoped_ptr<io::ZeroCopyOutputStream> output(
    output_directory->Open(filename));
  io::Printer printer(output.get(), '$');

  printer.Print(
    "// Generated by the protocol buffer compiler.  DO NOT EDIT!\r\n"
    "\r\n");

  // Namespace aliases to avoid lines getting horribly long
  printer.Print("using pb = global::Google.ProtocolBuffers;\r\n");
  printer.Print("using pbc = global::Google.ProtocolBuffers.Collections;\r\n");
  printer.Print("using pbd = global::Google.ProtocolBuffers.Descriptors;\r\n");
  printer.Print("using scg = global::System.Collections.Generic;\r\n");

  if (!csharp_namespace.empty()) {
    printer.Print(
      "namespace $namespace$ {\r\n",
      "namespace", csharp_namespace);
    printer.Indent();
  }
  printer.Print("\r\n");

  
  if (file->options().csharp_nest_classes()) {
    printer.Print(
    "$access$ static partial class $classname$ {\r\n\r\n",
    "classname", FileClassName(file),
    "access", ClassAccessLevel(file));
    printer.Indent();
  }

  GeneratorClass(descriptor).Generate(&printer);

  if (file->options().csharp_nest_classes()) {
    printer.Outdent();
    printer.Print("}\r\n");
  }

  if (!csharp_namespace.empty()) {
    printer.Outdent();
    printer.Print("}\r\n");
  }
}

void FileGenerator::GenerateSiblings(OutputDirectory* output_directory,
                                     vector<string>* file_list) {
  if (file_->options().csharp_multiple_files()) {
    for (int i = 0; i < file_->enum_type_count(); i++) {
      GenerateSibling<EnumGenerator>(csharp_namespace_,
                                     file_,
                                     file_->enum_type(i),
                                     output_directory, file_list);
    }
    for (int i = 0; i < file_->message_type_count(); i++) {
      GenerateSibling<MessageGenerator>(csharp_namespace_,
                                        file_,
                                        file_->message_type(i),
                                        output_directory, file_list);
    }
    for (int i = 0; i < file_->service_count(); i++) {
      GenerateSibling<ServiceGenerator>(csharp_namespace_,
                                        file_,
                                        file_->service(i),
                                        output_directory, file_list);
    }
  }
}

}  // namespace csharp
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
