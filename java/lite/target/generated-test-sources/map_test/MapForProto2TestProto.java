// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com/google/protobuf/map_for_proto2_test.proto

package map_test;

public final class MapForProto2TestProto {
  private MapForProto2TestProto() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface TestMapOrBuilder extends
      // @@protoc_insertion_point(interface_extends:map_for_proto2_test.TestMap)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    int getInt32ToInt32FieldCount();
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    boolean containsInt32ToInt32Field(
        int key);
    /**
     * Use {@link #getInt32ToInt32FieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, java.lang.Integer>
    getInt32ToInt32Field();
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    java.util.Map<java.lang.Integer, java.lang.Integer>
    getInt32ToInt32FieldMap();
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */

    int getInt32ToInt32FieldOrDefault(
        int key,
        int defaultValue);
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */

    int getInt32ToInt32FieldOrThrow(
        int key);

    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    int getInt32ToStringFieldCount();
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    boolean containsInt32ToStringField(
        int key);
    /**
     * Use {@link #getInt32ToStringFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, java.lang.String>
    getInt32ToStringField();
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    java.util.Map<java.lang.Integer, java.lang.String>
    getInt32ToStringFieldMap();
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */

    java.lang.String getInt32ToStringFieldOrDefault(
        int key,
        java.lang.String defaultValue);
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */

    java.lang.String getInt32ToStringFieldOrThrow(
        int key);

    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    int getInt32ToBytesFieldCount();
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    boolean containsInt32ToBytesField(
        int key);
    /**
     * Use {@link #getInt32ToBytesFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, com.google.protobuf.ByteString>
    getInt32ToBytesField();
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    java.util.Map<java.lang.Integer, com.google.protobuf.ByteString>
    getInt32ToBytesFieldMap();
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */

    com.google.protobuf.ByteString getInt32ToBytesFieldOrDefault(
        int key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */

    com.google.protobuf.ByteString getInt32ToBytesFieldOrThrow(
        int key);

    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    int getInt32ToEnumFieldCount();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    boolean containsInt32ToEnumField(
        int key);
    /**
     * Use {@link #getInt32ToEnumFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
    getInt32ToEnumField();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
    getInt32ToEnumFieldMap();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    map_test.MapForProto2TestProto.TestMap.EnumValue getInt32ToEnumFieldOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestMap.EnumValue defaultValue);
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    map_test.MapForProto2TestProto.TestMap.EnumValue getInt32ToEnumFieldOrThrow(
        int key);

    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    int getInt32ToMessageFieldCount();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    boolean containsInt32ToMessageField(
        int key);
    /**
     * Use {@link #getInt32ToMessageFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue>
    getInt32ToMessageField();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue>
    getInt32ToMessageFieldMap();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */

    map_test.MapForProto2TestProto.TestMap.MessageValue getInt32ToMessageFieldOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestMap.MessageValue defaultValue);
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */

    map_test.MapForProto2TestProto.TestMap.MessageValue getInt32ToMessageFieldOrThrow(
        int key);

    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    int getStringToInt32FieldCount();
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    boolean containsStringToInt32Field(
        java.lang.String key);
    /**
     * Use {@link #getStringToInt32FieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getStringToInt32Field();
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getStringToInt32FieldMap();
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */

    int getStringToInt32FieldOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */

    int getStringToInt32FieldOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    int getRequiredMessageMapCount();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    boolean containsRequiredMessageMap(
        int key);
    /**
     * Use {@link #getRequiredMessageMapMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>
    getRequiredMessageMap();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>
    getRequiredMessageMapMap();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */

    map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getRequiredMessageMapOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields defaultValue);
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */

    map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getRequiredMessageMapOrThrow(
        int key);
  }
  /**
   * Protobuf type {@code map_for_proto2_test.TestMap}
   */
  public  static final class TestMap extends
      com.google.protobuf.GeneratedMessageLite<
          TestMap, TestMap.Builder> implements
      // @@protoc_insertion_point(message_implements:map_for_proto2_test.TestMap)
      TestMapOrBuilder {
    private TestMap() {
    }
    /**
     * Protobuf enum {@code map_for_proto2_test.TestMap.EnumValue}
     */
    public enum EnumValue
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>FOO = 0;</code>
       */
      FOO(0),
      /**
       * <code>BAR = 1;</code>
       */
      BAR(1),
      /**
       * <code>BAZ = 2;</code>
       */
      BAZ(2),
      /**
       * <code>QUX = 3;</code>
       */
      QUX(3),
      ;

      /**
       * <code>FOO = 0;</code>
       */
      public static final int FOO_VALUE = 0;
      /**
       * <code>BAR = 1;</code>
       */
      public static final int BAR_VALUE = 1;
      /**
       * <code>BAZ = 2;</code>
       */
      public static final int BAZ_VALUE = 2;
      /**
       * <code>QUX = 3;</code>
       */
      public static final int QUX_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EnumValue valueOf(int value) {
        return forNumber(value);
      }

      public static EnumValue forNumber(int value) {
        switch (value) {
          case 0: return FOO;
          case 1: return BAR;
          case 2: return BAZ;
          case 3: return QUX;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<EnumValue>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          EnumValue> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EnumValue>() {
              @java.lang.Override
              public EnumValue findValueByNumber(int number) {
                return EnumValue.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return EnumValueVerifier.INSTANCE;
      }

      private static final class EnumValueVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new EnumValueVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return EnumValue.forNumber(number) != null;
              }
            };

      private final int value;

      private EnumValue(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:map_for_proto2_test.TestMap.EnumValue)
    }

    public interface MessageValueOrBuilder extends
        // @@protoc_insertion_point(interface_extends:map_for_proto2_test.TestMap.MessageValue)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional int32 value = 1;</code>
       * @return Whether the value field is set.
       */
      boolean hasValue();
      /**
       * <code>optional int32 value = 1;</code>
       * @return The value.
       */
      int getValue();
    }
    /**
     * Protobuf type {@code map_for_proto2_test.TestMap.MessageValue}
     */
    public  static final class MessageValue extends
        com.google.protobuf.GeneratedMessageLite<
            MessageValue, MessageValue.Builder> implements
        // @@protoc_insertion_point(message_implements:map_for_proto2_test.TestMap.MessageValue)
        MessageValueOrBuilder {
      private MessageValue() {
      }
      private int bitField0_;
      public static final int VALUE_FIELD_NUMBER = 1;
      private int value_;
      /**
       * <code>optional int32 value = 1;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional int32 value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public int getValue() {
        return value_;
      }
      /**
       * <code>optional int32 value = 1;</code>
       * @param value The value to set.
       */
      private void setValue(int value) {
        bitField0_ |= 0x00000001;
        value_ = value;
      }
      /**
       * <code>optional int32 value = 1;</code>
       */
      private void clearValue() {
        bitField0_ = (bitField0_ & ~0x00000001);
        value_ = 0;
      }

      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageValue parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(map_test.MapForProto2TestProto.TestMap.MessageValue prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code map_for_proto2_test.TestMap.MessageValue}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            map_test.MapForProto2TestProto.TestMap.MessageValue, Builder> implements
          // @@protoc_insertion_point(builder_implements:map_for_proto2_test.TestMap.MessageValue)
          map_test.MapForProto2TestProto.TestMap.MessageValueOrBuilder {
        // Construct using map_test.MapForProto2TestProto.TestMap.MessageValue.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional int32 value = 1;</code>
         * @return Whether the value field is set.
         */
        @java.lang.Override
        public boolean hasValue() {
          return instance.hasValue();
        }
        /**
         * <code>optional int32 value = 1;</code>
         * @return The value.
         */
        @java.lang.Override
        public int getValue() {
          return instance.getValue();
        }
        /**
         * <code>optional int32 value = 1;</code>
         * @param value The value to set.
         * @return This builder for chaining.
         */
        public Builder setValue(int value) {
          copyOnWrite();
          instance.setValue(value);
          return this;
        }
        /**
         * <code>optional int32 value = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearValue() {
          copyOnWrite();
          instance.clearValue();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:map_for_proto2_test.TestMap.MessageValue)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new map_test.MapForProto2TestProto.TestMap.MessageValue();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "value_",
              };
              java.lang.String info =
                  "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u1004\u0000";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<map_test.MapForProto2TestProto.TestMap.MessageValue> parser = PARSER;
            if (parser == null) {
              synchronized (map_test.MapForProto2TestProto.TestMap.MessageValue.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.TestMap.MessageValue>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:map_for_proto2_test.TestMap.MessageValue)
      private static final map_test.MapForProto2TestProto.TestMap.MessageValue DEFAULT_INSTANCE;
      static {
        MessageValue defaultInstance = new MessageValue();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          MessageValue.class, defaultInstance);
      }

      public static map_test.MapForProto2TestProto.TestMap.MessageValue getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<MessageValue> PARSER;

      public static com.google.protobuf.Parser<MessageValue> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface MessageWithRequiredFieldsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:map_for_proto2_test.TestMap.MessageWithRequiredFields)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>required int32 value = 1;</code>
       * @return Whether the value field is set.
       */
      boolean hasValue();
      /**
       * <code>required int32 value = 1;</code>
       * @return The value.
       */
      int getValue();
    }
    /**
     * Protobuf type {@code map_for_proto2_test.TestMap.MessageWithRequiredFields}
     */
    public  static final class MessageWithRequiredFields extends
        com.google.protobuf.GeneratedMessageLite<
            MessageWithRequiredFields, MessageWithRequiredFields.Builder> implements
        // @@protoc_insertion_point(message_implements:map_for_proto2_test.TestMap.MessageWithRequiredFields)
        MessageWithRequiredFieldsOrBuilder {
      private MessageWithRequiredFields() {
      }
      private int bitField0_;
      public static final int VALUE_FIELD_NUMBER = 1;
      private int value_;
      /**
       * <code>required int32 value = 1;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required int32 value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public int getValue() {
        return value_;
      }
      /**
       * <code>required int32 value = 1;</code>
       * @param value The value to set.
       */
      private void setValue(int value) {
        bitField0_ |= 0x00000001;
        value_ = value;
      }
      /**
       * <code>required int32 value = 1;</code>
       */
      private void clearValue() {
        bitField0_ = (bitField0_ & ~0x00000001);
        value_ = 0;
      }

      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code map_for_proto2_test.TestMap.MessageWithRequiredFields}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields, Builder> implements
          // @@protoc_insertion_point(builder_implements:map_for_proto2_test.TestMap.MessageWithRequiredFields)
          map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFieldsOrBuilder {
        // Construct using map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>required int32 value = 1;</code>
         * @return Whether the value field is set.
         */
        @java.lang.Override
        public boolean hasValue() {
          return instance.hasValue();
        }
        /**
         * <code>required int32 value = 1;</code>
         * @return The value.
         */
        @java.lang.Override
        public int getValue() {
          return instance.getValue();
        }
        /**
         * <code>required int32 value = 1;</code>
         * @param value The value to set.
         * @return This builder for chaining.
         */
        public Builder setValue(int value) {
          copyOnWrite();
          instance.setValue(value);
          return this;
        }
        /**
         * <code>required int32 value = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearValue() {
          copyOnWrite();
          instance.clearValue();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:map_for_proto2_test.TestMap.MessageWithRequiredFields)
      }
      private byte memoizedIsInitialized = 2;
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "value_",
              };
              java.lang.String info =
                  "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0001\u0001\u1504\u0000";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> parser = PARSER;
            if (parser == null) {
              synchronized (map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return memoizedIsInitialized;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:map_for_proto2_test.TestMap.MessageWithRequiredFields)
      private static final map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields DEFAULT_INSTANCE;
      static {
        MessageWithRequiredFields defaultInstance = new MessageWithRequiredFields();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          MessageWithRequiredFields.class, defaultInstance);
      }

      public static map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<MessageWithRequiredFields> PARSER;

      public static com.google.protobuf.Parser<MessageWithRequiredFields> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public static final int INT32_TO_INT32_FIELD_FIELD_NUMBER = 1;
    private static final class Int32ToInt32FieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, java.lang.Integer> int32ToInt32Field_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetInt32ToInt32Field() {
      return int32ToInt32Field_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetMutableInt32ToInt32Field() {
      if (!int32ToInt32Field_.isMutable()) {
        int32ToInt32Field_ = int32ToInt32Field_.mutableCopy();
      }
      return int32ToInt32Field_;
    }
    @java.lang.Override

    public int getInt32ToInt32FieldCount() {
      return internalGetInt32ToInt32Field().size();
    }
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToInt32Field(
        int key) {
      
      return internalGetInt32ToInt32Field().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToInt32FieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32Field() {
      return getInt32ToInt32FieldMap();
    }
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32FieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToInt32Field());
    }
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public int getInt32ToInt32FieldOrDefault(
        int key,
        int defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetInt32ToInt32Field();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public int getInt32ToInt32FieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetInt32ToInt32Field();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
     */
    private java.util.Map<java.lang.Integer, java.lang.Integer>
    getMutableInt32ToInt32FieldMap() {
      return internalGetMutableInt32ToInt32Field();
    }

    public static final int INT32_TO_STRING_FIELD_FIELD_NUMBER = 2;
    private static final class Int32ToStringFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, java.lang.String>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, java.lang.String> int32ToStringField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.String>
    internalGetInt32ToStringField() {
      return int32ToStringField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.String>
    internalGetMutableInt32ToStringField() {
      if (!int32ToStringField_.isMutable()) {
        int32ToStringField_ = int32ToStringField_.mutableCopy();
      }
      return int32ToStringField_;
    }
    @java.lang.Override

    public int getInt32ToStringFieldCount() {
      return internalGetInt32ToStringField().size();
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToStringField(
        int key) {
      
      return internalGetInt32ToStringField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToStringFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToStringField() {
      return getInt32ToStringFieldMap();
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToStringFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToStringField());
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public java.lang.String getInt32ToStringFieldOrDefault(
        int key,
        java.lang.String defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.String> map =
          internalGetInt32ToStringField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public java.lang.String getInt32ToStringFieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.String> map =
          internalGetInt32ToStringField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
     */
    private java.util.Map<java.lang.Integer, java.lang.String>
    getMutableInt32ToStringFieldMap() {
      return internalGetMutableInt32ToStringField();
    }

    public static final int INT32_TO_BYTES_FIELD_FIELD_NUMBER = 3;
    private static final class Int32ToBytesFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, com.google.protobuf.ByteString> int32ToBytesField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, com.google.protobuf.ByteString>
    internalGetInt32ToBytesField() {
      return int32ToBytesField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, com.google.protobuf.ByteString>
    internalGetMutableInt32ToBytesField() {
      if (!int32ToBytesField_.isMutable()) {
        int32ToBytesField_ = int32ToBytesField_.mutableCopy();
      }
      return int32ToBytesField_;
    }
    @java.lang.Override

    public int getInt32ToBytesFieldCount() {
      return internalGetInt32ToBytesField().size();
    }
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToBytesField(
        int key) {
      
      return internalGetInt32ToBytesField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToBytesFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToBytesField() {
      return getInt32ToBytesFieldMap();
    }
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToBytesFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToBytesField());
    }
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToBytesFieldOrDefault(
        int key,
        com.google.protobuf.ByteString defaultValue) {
      
      java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
          internalGetInt32ToBytesField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToBytesFieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
          internalGetInt32ToBytesField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
     */
    private java.util.Map<java.lang.Integer, com.google.protobuf.ByteString>
    getMutableInt32ToBytesFieldMap() {
      return internalGetMutableInt32ToBytesField();
    }

    public static final int INT32_TO_ENUM_FIELD_FIELD_NUMBER = 4;
    private static final class Int32ToEnumFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.TestMap.EnumValue.FOO.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, java.lang.Integer> int32ToEnumField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetInt32ToEnumField() {
      return int32ToEnumField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetMutableInt32ToEnumField() {
      if (!int32ToEnumField_.isMutable()) {
        int32ToEnumField_ = int32ToEnumField_.mutableCopy();
      }
      return int32ToEnumField_;
    }
    @java.lang.Override

    public int getInt32ToEnumFieldCount() {
      return internalGetInt32ToEnumField().size();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToEnumField(
        int key) {
      
      return internalGetInt32ToEnumField().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue> int32ToEnumFieldValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.TestMap.EnumValue.internalGetValueMap(),
                map_test.MapForProto2TestProto.TestMap.EnumValue.FOO);
    /**
     * Use {@link #getInt32ToEnumFieldMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
    getInt32ToEnumField() {
      return getInt32ToEnumFieldMap();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
    getInt32ToEnumFieldMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue, java.lang.Integer>(
                internalGetInt32ToEnumField(),
                int32ToEnumFieldValueConverter));
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestMap.EnumValue getInt32ToEnumFieldOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestMap.EnumValue defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetInt32ToEnumField();
      return map.containsKey(key)
             ? int32ToEnumFieldValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestMap.EnumValue getInt32ToEnumFieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetInt32ToEnumField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return int32ToEnumFieldValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
     */
    private java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
    getMutableInt32ToEnumFieldMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue, java.lang.Integer>(
              internalGetMutableInt32ToEnumField(),
              int32ToEnumFieldValueConverter);
    }

    public static final int INT32_TO_MESSAGE_FIELD_FIELD_NUMBER = 5;
    private static final class Int32ToMessageFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  map_test.MapForProto2TestProto.TestMap.MessageValue.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> int32ToMessageField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue>
    internalGetInt32ToMessageField() {
      return int32ToMessageField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue>
    internalGetMutableInt32ToMessageField() {
      if (!int32ToMessageField_.isMutable()) {
        int32ToMessageField_ = int32ToMessageField_.mutableCopy();
      }
      return int32ToMessageField_;
    }
    @java.lang.Override

    public int getInt32ToMessageFieldCount() {
      return internalGetInt32ToMessageField().size();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToMessageField(
        int key) {
      
      return internalGetInt32ToMessageField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToMessageFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> getInt32ToMessageField() {
      return getInt32ToMessageFieldMap();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> getInt32ToMessageFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToMessageField());
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestMap.MessageValue getInt32ToMessageFieldOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestMap.MessageValue defaultValue) {
      
      java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> map =
          internalGetInt32ToMessageField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestMap.MessageValue getInt32ToMessageFieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> map =
          internalGetInt32ToMessageField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
     */
    private java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue>
    getMutableInt32ToMessageFieldMap() {
      return internalGetMutableInt32ToMessageField();
    }

    public static final int STRING_TO_INT32_FIELD_FIELD_NUMBER = 6;
    private static final class StringToInt32FieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> stringToInt32Field_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetStringToInt32Field() {
      return stringToInt32Field_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableStringToInt32Field() {
      if (!stringToInt32Field_.isMutable()) {
        stringToInt32Field_ = stringToInt32Field_.mutableCopy();
      }
      return stringToInt32Field_;
    }
    @java.lang.Override

    public int getStringToInt32FieldCount() {
      return internalGetStringToInt32Field().size();
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public boolean containsStringToInt32Field(
        java.lang.String key) {
      key.getClass();
      return internalGetStringToInt32Field().containsKey(key);
    }
    /**
     * Use {@link #getStringToInt32FieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32Field() {
      return getStringToInt32FieldMap();
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32FieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetStringToInt32Field());
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public int getStringToInt32FieldOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToInt32Field();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public int getStringToInt32FieldOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetStringToInt32Field();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableStringToInt32FieldMap() {
      return internalGetMutableStringToInt32Field();
    }

    public static final int REQUIRED_MESSAGE_MAP_FIELD_NUMBER = 11;
    private static final class RequiredMessageMapDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> requiredMessageMap_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>
    internalGetRequiredMessageMap() {
      return requiredMessageMap_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>
    internalGetMutableRequiredMessageMap() {
      if (!requiredMessageMap_.isMutable()) {
        requiredMessageMap_ = requiredMessageMap_.mutableCopy();
      }
      return requiredMessageMap_;
    }
    @java.lang.Override

    public int getRequiredMessageMapCount() {
      return internalGetRequiredMessageMap().size();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    @java.lang.Override

    public boolean containsRequiredMessageMap(
        int key) {
      
      return internalGetRequiredMessageMap().containsKey(key);
    }
    /**
     * Use {@link #getRequiredMessageMapMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> getRequiredMessageMap() {
      return getRequiredMessageMapMap();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> getRequiredMessageMapMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetRequiredMessageMap());
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getRequiredMessageMapOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields defaultValue) {
      
      java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> map =
          internalGetRequiredMessageMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getRequiredMessageMapOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> map =
          internalGetRequiredMessageMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
     */
    private java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields>
    getMutableRequiredMessageMapMap() {
      return internalGetMutableRequiredMessageMap();
    }

    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestMap parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestMap parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestMap parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(map_test.MapForProto2TestProto.TestMap prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code map_for_proto2_test.TestMap}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          map_test.MapForProto2TestProto.TestMap, Builder> implements
        // @@protoc_insertion_point(builder_implements:map_for_proto2_test.TestMap)
        map_test.MapForProto2TestProto.TestMapOrBuilder {
      // Construct using map_test.MapForProto2TestProto.TestMap.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getInt32ToInt32FieldCount() {
        return instance.getInt32ToInt32FieldMap().size();
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToInt32Field(
          int key) {
        
        return instance.getInt32ToInt32FieldMap().containsKey(key);
      }

      public Builder clearInt32ToInt32Field() {
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */

      public Builder removeInt32ToInt32Field(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToInt32FieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32Field() {
        return getInt32ToInt32FieldMap();
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32FieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToInt32FieldMap());
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override

      public int getInt32ToInt32FieldOrDefault(
          int key,
          int defaultValue) {
        
        java.util.Map<java.lang.Integer, java.lang.Integer> map =
            instance.getInt32ToInt32FieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override

      public int getInt32ToInt32FieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, java.lang.Integer> map =
            instance.getInt32ToInt32FieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */
      public Builder putInt32ToInt32Field(
          int key,
          int value) {
        
        
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 1;</code>
       */
      public Builder putAllInt32ToInt32Field(
          java.util.Map<java.lang.Integer, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToStringFieldCount() {
        return instance.getInt32ToStringFieldMap().size();
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToStringField(
          int key) {
        
        return instance.getInt32ToStringFieldMap().containsKey(key);
      }

      public Builder clearInt32ToStringField() {
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */

      public Builder removeInt32ToStringField(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToStringFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToStringField() {
        return getInt32ToStringFieldMap();
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, java.lang.String> getInt32ToStringFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToStringFieldMap());
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override

      public java.lang.String getInt32ToStringFieldOrDefault(
          int key,
          java.lang.String defaultValue) {
        
        java.util.Map<java.lang.Integer, java.lang.String> map =
            instance.getInt32ToStringFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override

      public java.lang.String getInt32ToStringFieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, java.lang.String> map =
            instance.getInt32ToStringFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */
      public Builder putInt32ToStringField(
          int key,
          java.lang.String value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, string&gt; int32_to_string_field = 2;</code>
       */
      public Builder putAllInt32ToStringField(
          java.util.Map<java.lang.Integer, java.lang.String> values) {
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToBytesFieldCount() {
        return instance.getInt32ToBytesFieldMap().size();
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToBytesField(
          int key) {
        
        return instance.getInt32ToBytesFieldMap().containsKey(key);
      }

      public Builder clearInt32ToBytesField() {
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */

      public Builder removeInt32ToBytesField(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToBytesFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToBytesField() {
        return getInt32ToBytesFieldMap();
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToBytesFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToBytesFieldMap());
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToBytesFieldOrDefault(
          int key,
          com.google.protobuf.ByteString defaultValue) {
        
        java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
            instance.getInt32ToBytesFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToBytesFieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
            instance.getInt32ToBytesFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */
      public Builder putInt32ToBytesField(
          int key,
          com.google.protobuf.ByteString value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, bytes&gt; int32_to_bytes_field = 3;</code>
       */
      public Builder putAllInt32ToBytesField(
          java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToEnumFieldCount() {
        return instance.getInt32ToEnumFieldMap().size();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToEnumField(
          int key) {
        
        return instance.getInt32ToEnumFieldMap().containsKey(key);
      }

      public Builder clearInt32ToEnumField() {
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */

      public Builder removeInt32ToEnumField(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToEnumFieldMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
      getInt32ToEnumField() {
        return getInt32ToEnumFieldMap();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue>
      getInt32ToEnumFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToEnumFieldMap());
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestMap.EnumValue getInt32ToEnumFieldOrDefault(
          int key,
          map_test.MapForProto2TestProto.TestMap.EnumValue defaultValue) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue> map =
            instance.getInt32ToEnumFieldMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestMap.EnumValue getInt32ToEnumFieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue> map =
            instance.getInt32ToEnumFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */
      public Builder putInt32ToEnumField(
          int key,
          map_test.MapForProto2TestProto.TestMap.EnumValue value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.EnumValue&gt; int32_to_enum_field = 4;</code>
       */
      public Builder putAllInt32ToEnumField(
          java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.EnumValue> values) {
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToMessageFieldCount() {
        return instance.getInt32ToMessageFieldMap().size();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToMessageField(
          int key) {
        
        return instance.getInt32ToMessageFieldMap().containsKey(key);
      }

      public Builder clearInt32ToMessageField() {
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */

      public Builder removeInt32ToMessageField(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToMessageFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> getInt32ToMessageField() {
        return getInt32ToMessageFieldMap();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> getInt32ToMessageFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToMessageFieldMap());
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestMap.MessageValue getInt32ToMessageFieldOrDefault(
          int key,
          map_test.MapForProto2TestProto.TestMap.MessageValue defaultValue) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> map =
            instance.getInt32ToMessageFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestMap.MessageValue getInt32ToMessageFieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> map =
            instance.getInt32ToMessageFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */
      public Builder putInt32ToMessageField(
          int key,
          map_test.MapForProto2TestProto.TestMap.MessageValue value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageValue&gt; int32_to_message_field = 5;</code>
       */
      public Builder putAllInt32ToMessageField(
          java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageValue> values) {
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getStringToInt32FieldCount() {
        return instance.getStringToInt32FieldMap().size();
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override

      public boolean containsStringToInt32Field(
          java.lang.String key) {
        key.getClass();
        return instance.getStringToInt32FieldMap().containsKey(key);
      }

      public Builder clearStringToInt32Field() {
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */

      public Builder removeStringToInt32Field(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getStringToInt32FieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32Field() {
        return getStringToInt32FieldMap();
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getStringToInt32FieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getStringToInt32FieldMap());
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override

      public int getStringToInt32FieldOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getStringToInt32FieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override

      public int getStringToInt32FieldOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getStringToInt32FieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */
      public Builder putStringToInt32Field(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, int32&gt; string_to_int32_field = 6;</code>
       */
      public Builder putAllStringToInt32Field(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getRequiredMessageMapCount() {
        return instance.getRequiredMessageMapMap().size();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */
      @java.lang.Override

      public boolean containsRequiredMessageMap(
          int key) {
        
        return instance.getRequiredMessageMapMap().containsKey(key);
      }

      public Builder clearRequiredMessageMap() {
        copyOnWrite();
        instance.getMutableRequiredMessageMapMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */

      public Builder removeRequiredMessageMap(
          int key) {
        
        copyOnWrite();
        instance.getMutableRequiredMessageMapMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getRequiredMessageMapMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> getRequiredMessageMap() {
        return getRequiredMessageMapMap();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> getRequiredMessageMapMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getRequiredMessageMapMap());
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getRequiredMessageMapOrDefault(
          int key,
          map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields defaultValue) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> map =
            instance.getRequiredMessageMapMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields getRequiredMessageMapOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> map =
            instance.getRequiredMessageMapMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */
      public Builder putRequiredMessageMap(
          int key,
          map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableRequiredMessageMapMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestMap.MessageWithRequiredFields&gt; required_message_map = 11;</code>
       */
      public Builder putAllRequiredMessageMap(
          java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestMap.MessageWithRequiredFields> values) {
        copyOnWrite();
        instance.getMutableRequiredMessageMapMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:map_for_proto2_test.TestMap)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new map_test.MapForProto2TestProto.TestMap();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "int32ToInt32Field_",
              Int32ToInt32FieldDefaultEntryHolder.defaultEntry,
              "int32ToStringField_",
              Int32ToStringFieldDefaultEntryHolder.defaultEntry,
              "int32ToBytesField_",
              Int32ToBytesFieldDefaultEntryHolder.defaultEntry,
              "int32ToEnumField_",
              Int32ToEnumFieldDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.TestMap.EnumValue.internalGetVerifier(),
              "int32ToMessageField_",
              Int32ToMessageFieldDefaultEntryHolder.defaultEntry,
              "stringToInt32Field_",
              StringToInt32FieldDefaultEntryHolder.defaultEntry,
              "requiredMessageMap_",
              RequiredMessageMapDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0001\u0007\u0000\u0000\u0001\u000b\u0007\u0007\u0000\u0001\u00012\u00022\u0003" +
                "2\u0004\u0832\u00052\u00062\u000b\u0432";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<map_test.MapForProto2TestProto.TestMap> parser = PARSER;
          if (parser == null) {
            synchronized (map_test.MapForProto2TestProto.TestMap.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.TestMap>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:map_for_proto2_test.TestMap)
    private static final map_test.MapForProto2TestProto.TestMap DEFAULT_INSTANCE;
    static {
      TestMap defaultInstance = new TestMap();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TestMap.class, defaultInstance);
    }

    public static map_test.MapForProto2TestProto.TestMap getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TestMap> PARSER;

    public static com.google.protobuf.Parser<TestMap> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TestUnknownEnumValueOrBuilder extends
      // @@protoc_insertion_point(interface_extends:map_for_proto2_test.TestUnknownEnumValue)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    int getInt32ToInt32FieldCount();
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    boolean containsInt32ToInt32Field(
        int key);
    /**
     * Use {@link #getInt32ToInt32FieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, java.lang.Integer>
    getInt32ToInt32Field();
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    java.util.Map<java.lang.Integer, java.lang.Integer>
    getInt32ToInt32FieldMap();
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */

    int getInt32ToInt32FieldOrDefault(
        int key,
        int defaultValue);
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */

    int getInt32ToInt32FieldOrThrow(
        int key);
  }
  /**
   * Protobuf type {@code map_for_proto2_test.TestUnknownEnumValue}
   */
  public  static final class TestUnknownEnumValue extends
      com.google.protobuf.GeneratedMessageLite<
          TestUnknownEnumValue, TestUnknownEnumValue.Builder> implements
      // @@protoc_insertion_point(message_implements:map_for_proto2_test.TestUnknownEnumValue)
      TestUnknownEnumValueOrBuilder {
    private TestUnknownEnumValue() {
    }
    public static final int INT32_TO_INT32_FIELD_FIELD_NUMBER = 4;
    private static final class Int32ToInt32FieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, java.lang.Integer> int32ToInt32Field_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetInt32ToInt32Field() {
      return int32ToInt32Field_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetMutableInt32ToInt32Field() {
      if (!int32ToInt32Field_.isMutable()) {
        int32ToInt32Field_ = int32ToInt32Field_.mutableCopy();
      }
      return int32ToInt32Field_;
    }
    @java.lang.Override

    public int getInt32ToInt32FieldCount() {
      return internalGetInt32ToInt32Field().size();
    }
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToInt32Field(
        int key) {
      
      return internalGetInt32ToInt32Field().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToInt32FieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32Field() {
      return getInt32ToInt32FieldMap();
    }
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32FieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToInt32Field());
    }
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    @java.lang.Override

    public int getInt32ToInt32FieldOrDefault(
        int key,
        int defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetInt32ToInt32Field();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    @java.lang.Override

    public int getInt32ToInt32FieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetInt32ToInt32Field();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * Wire-compatible with TestMap.int32_to_enum_field so we can test the
     * parsing behavior of TestMap regarding unknown enum values.
     * </pre>
     *
     * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
     */
    private java.util.Map<java.lang.Integer, java.lang.Integer>
    getMutableInt32ToInt32FieldMap() {
      return internalGetMutableInt32ToInt32Field();
    }

    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestUnknownEnumValue parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(map_test.MapForProto2TestProto.TestUnknownEnumValue prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code map_for_proto2_test.TestUnknownEnumValue}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          map_test.MapForProto2TestProto.TestUnknownEnumValue, Builder> implements
        // @@protoc_insertion_point(builder_implements:map_for_proto2_test.TestUnknownEnumValue)
        map_test.MapForProto2TestProto.TestUnknownEnumValueOrBuilder {
      // Construct using map_test.MapForProto2TestProto.TestUnknownEnumValue.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getInt32ToInt32FieldCount() {
        return instance.getInt32ToInt32FieldMap().size();
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToInt32Field(
          int key) {
        
        return instance.getInt32ToInt32FieldMap().containsKey(key);
      }

      public Builder clearInt32ToInt32Field() {
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */

      public Builder removeInt32ToInt32Field(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToInt32FieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32Field() {
        return getInt32ToInt32FieldMap();
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, java.lang.Integer> getInt32ToInt32FieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToInt32FieldMap());
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */
      @java.lang.Override

      public int getInt32ToInt32FieldOrDefault(
          int key,
          int defaultValue) {
        
        java.util.Map<java.lang.Integer, java.lang.Integer> map =
            instance.getInt32ToInt32FieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */
      @java.lang.Override

      public int getInt32ToInt32FieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, java.lang.Integer> map =
            instance.getInt32ToInt32FieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */
      public Builder putInt32ToInt32Field(
          int key,
          int value) {
        
        
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Wire-compatible with TestMap.int32_to_enum_field so we can test the
       * parsing behavior of TestMap regarding unknown enum values.
       * </pre>
       *
       * <code>map&lt;int32, int32&gt; int32_to_int32_field = 4;</code>
       */
      public Builder putAllInt32ToInt32Field(
          java.util.Map<java.lang.Integer, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:map_for_proto2_test.TestUnknownEnumValue)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new map_test.MapForProto2TestProto.TestUnknownEnumValue();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "int32ToInt32Field_",
              Int32ToInt32FieldDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0004\u0004\u0001\u0001\u0000\u0000\u00042";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<map_test.MapForProto2TestProto.TestUnknownEnumValue> parser = PARSER;
          if (parser == null) {
            synchronized (map_test.MapForProto2TestProto.TestUnknownEnumValue.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.TestUnknownEnumValue>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:map_for_proto2_test.TestUnknownEnumValue)
    private static final map_test.MapForProto2TestProto.TestUnknownEnumValue DEFAULT_INSTANCE;
    static {
      TestUnknownEnumValue defaultInstance = new TestUnknownEnumValue();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TestUnknownEnumValue.class, defaultInstance);
    }

    public static map_test.MapForProto2TestProto.TestUnknownEnumValue getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TestUnknownEnumValue> PARSER;

    public static com.google.protobuf.Parser<TestUnknownEnumValue> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TestRecursiveMapOrBuilder extends
      // @@protoc_insertion_point(interface_extends:map_for_proto2_test.TestRecursiveMap)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional int32 value = 1;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <code>optional int32 value = 1;</code>
     * @return The value.
     */
    int getValue();

    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    int getRecursiveMapFieldCount();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    boolean containsRecursiveMapField(
        int key);
    /**
     * Use {@link #getRecursiveMapFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap>
    getRecursiveMapField();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap>
    getRecursiveMapFieldMap();
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */

    map_test.MapForProto2TestProto.TestRecursiveMap getRecursiveMapFieldOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestRecursiveMap defaultValue);
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */

    map_test.MapForProto2TestProto.TestRecursiveMap getRecursiveMapFieldOrThrow(
        int key);
  }
  /**
   * <pre>
   * Test that the maps initialization code works correctly when the map field
   * references the containing message.
   * </pre>
   *
   * Protobuf type {@code map_for_proto2_test.TestRecursiveMap}
   */
  public  static final class TestRecursiveMap extends
      com.google.protobuf.GeneratedMessageLite<
          TestRecursiveMap, TestRecursiveMap.Builder> implements
      // @@protoc_insertion_point(message_implements:map_for_proto2_test.TestRecursiveMap)
      TestRecursiveMapOrBuilder {
    private TestRecursiveMap() {
    }
    private int bitField0_;
    public static final int VALUE_FIELD_NUMBER = 1;
    private int value_;
    /**
     * <code>optional int32 value = 1;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional int32 value = 1;</code>
     * @return The value.
     */
    @java.lang.Override
    public int getValue() {
      return value_;
    }
    /**
     * <code>optional int32 value = 1;</code>
     * @param value The value to set.
     */
    private void setValue(int value) {
      bitField0_ |= 0x00000001;
      value_ = value;
    }
    /**
     * <code>optional int32 value = 1;</code>
     */
    private void clearValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      value_ = 0;
    }

    public static final int RECURSIVE_MAP_FIELD_FIELD_NUMBER = 2;
    private static final class RecursiveMapFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  map_test.MapForProto2TestProto.TestRecursiveMap.getDefaultInstance());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> recursiveMapField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap>
    internalGetRecursiveMapField() {
      return recursiveMapField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap>
    internalGetMutableRecursiveMapField() {
      if (!recursiveMapField_.isMutable()) {
        recursiveMapField_ = recursiveMapField_.mutableCopy();
      }
      return recursiveMapField_;
    }
    @java.lang.Override

    public int getRecursiveMapFieldCount() {
      return internalGetRecursiveMapField().size();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    @java.lang.Override

    public boolean containsRecursiveMapField(
        int key) {
      
      return internalGetRecursiveMapField().containsKey(key);
    }
    /**
     * Use {@link #getRecursiveMapFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> getRecursiveMapField() {
      return getRecursiveMapFieldMap();
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> getRecursiveMapFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetRecursiveMapField());
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestRecursiveMap getRecursiveMapFieldOrDefault(
        int key,
        map_test.MapForProto2TestProto.TestRecursiveMap defaultValue) {
      
      java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> map =
          internalGetRecursiveMapField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.TestRecursiveMap getRecursiveMapFieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> map =
          internalGetRecursiveMapField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
     */
    private java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap>
    getMutableRecursiveMapFieldMap() {
      return internalGetMutableRecursiveMapField();
    }

    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.TestRecursiveMap parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(map_test.MapForProto2TestProto.TestRecursiveMap prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Test that the maps initialization code works correctly when the map field
     * references the containing message.
     * </pre>
     *
     * Protobuf type {@code map_for_proto2_test.TestRecursiveMap}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          map_test.MapForProto2TestProto.TestRecursiveMap, Builder> implements
        // @@protoc_insertion_point(builder_implements:map_for_proto2_test.TestRecursiveMap)
        map_test.MapForProto2TestProto.TestRecursiveMapOrBuilder {
      // Construct using map_test.MapForProto2TestProto.TestRecursiveMap.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional int32 value = 1;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <code>optional int32 value = 1;</code>
       * @return The value.
       */
      @java.lang.Override
      public int getValue() {
        return instance.getValue();
      }
      /**
       * <code>optional int32 value = 1;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(int value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <code>optional int32 value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      @java.lang.Override

      public int getRecursiveMapFieldCount() {
        return instance.getRecursiveMapFieldMap().size();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */
      @java.lang.Override

      public boolean containsRecursiveMapField(
          int key) {
        
        return instance.getRecursiveMapFieldMap().containsKey(key);
      }

      public Builder clearRecursiveMapField() {
        copyOnWrite();
        instance.getMutableRecursiveMapFieldMap().clear();
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */

      public Builder removeRecursiveMapField(
          int key) {
        
        copyOnWrite();
        instance.getMutableRecursiveMapFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getRecursiveMapFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> getRecursiveMapField() {
        return getRecursiveMapFieldMap();
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> getRecursiveMapFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getRecursiveMapFieldMap());
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestRecursiveMap getRecursiveMapFieldOrDefault(
          int key,
          map_test.MapForProto2TestProto.TestRecursiveMap defaultValue) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> map =
            instance.getRecursiveMapFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.TestRecursiveMap getRecursiveMapFieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> map =
            instance.getRecursiveMapFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */
      public Builder putRecursiveMapField(
          int key,
          map_test.MapForProto2TestProto.TestRecursiveMap value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableRecursiveMapFieldMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, .map_for_proto2_test.TestRecursiveMap&gt; recursive_map_field = 2;</code>
       */
      public Builder putAllRecursiveMapField(
          java.util.Map<java.lang.Integer, map_test.MapForProto2TestProto.TestRecursiveMap> values) {
        copyOnWrite();
        instance.getMutableRecursiveMapFieldMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:map_for_proto2_test.TestRecursiveMap)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new map_test.MapForProto2TestProto.TestRecursiveMap();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "value_",
              "recursiveMapField_",
              RecursiveMapFieldDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0001\u0000\u0000\u0001\u1004\u0000\u0002" +
                "2";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<map_test.MapForProto2TestProto.TestRecursiveMap> parser = PARSER;
          if (parser == null) {
            synchronized (map_test.MapForProto2TestProto.TestRecursiveMap.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.TestRecursiveMap>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:map_for_proto2_test.TestRecursiveMap)
    private static final map_test.MapForProto2TestProto.TestRecursiveMap DEFAULT_INSTANCE;
    static {
      TestRecursiveMap defaultInstance = new TestRecursiveMap();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TestRecursiveMap.class, defaultInstance);
    }

    public static map_test.MapForProto2TestProto.TestRecursiveMap getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TestRecursiveMap> PARSER;

    public static com.google.protobuf.Parser<TestRecursiveMap> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BizarroTestMapOrBuilder extends
      // @@protoc_insertion_point(interface_extends:map_for_proto2_test.BizarroTestMap)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    int getInt32ToInt32FieldCount();
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    boolean containsInt32ToInt32Field(
        int key);
    /**
     * Use {@link #getInt32ToInt32FieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, com.google.protobuf.ByteString>
    getInt32ToInt32Field();
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    java.util.Map<java.lang.Integer, com.google.protobuf.ByteString>
    getInt32ToInt32FieldMap();
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */

    com.google.protobuf.ByteString getInt32ToInt32FieldOrDefault(
        int key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */

    com.google.protobuf.ByteString getInt32ToInt32FieldOrThrow(
        int key);

    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    int getInt32ToStringFieldCount();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    boolean containsInt32ToStringField(
        java.lang.String key);
    /**
     * Use {@link #getInt32ToStringFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getInt32ToStringField();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getInt32ToStringFieldMap();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */

    int getInt32ToStringFieldOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */

    int getInt32ToStringFieldOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    int getInt32ToBytesFieldCount();
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    boolean containsInt32ToBytesField(
        java.lang.String key);
    /**
     * Use {@link #getInt32ToBytesFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getInt32ToBytesField();
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getInt32ToBytesFieldMap();
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */

    int getInt32ToBytesFieldOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */

    int getInt32ToBytesFieldOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    int getInt32ToEnumFieldCount();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    boolean containsInt32ToEnumField(
        java.lang.String key);
    /**
     * Use {@link #getInt32ToEnumFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getInt32ToEnumField();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getInt32ToEnumFieldMap();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */

    com.google.protobuf.ByteString getInt32ToEnumFieldOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */

    com.google.protobuf.ByteString getInt32ToEnumFieldOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    int getInt32ToMessageFieldCount();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    boolean containsInt32ToMessageField(
        java.lang.String key);
    /**
     * Use {@link #getInt32ToMessageFieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getInt32ToMessageField();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getInt32ToMessageFieldMap();
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */

    com.google.protobuf.ByteString getInt32ToMessageFieldOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */

    com.google.protobuf.ByteString getInt32ToMessageFieldOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    int getStringToInt32FieldCount();
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    boolean containsStringToInt32Field(
        java.lang.String key);
    /**
     * Use {@link #getStringToInt32FieldMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getStringToInt32Field();
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getStringToInt32FieldMap();
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */

    com.google.protobuf.ByteString getStringToInt32FieldOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */

    com.google.protobuf.ByteString getStringToInt32FieldOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * a decoy of TestMap for testing parsing errors
   * </pre>
   *
   * Protobuf type {@code map_for_proto2_test.BizarroTestMap}
   */
  public  static final class BizarroTestMap extends
      com.google.protobuf.GeneratedMessageLite<
          BizarroTestMap, BizarroTestMap.Builder> implements
      // @@protoc_insertion_point(message_implements:map_for_proto2_test.BizarroTestMap)
      BizarroTestMapOrBuilder {
    private BizarroTestMap() {
    }
    public static final int INT32_TO_INT32_FIELD_FIELD_NUMBER = 1;
    private static final class Int32ToInt32FieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, com.google.protobuf.ByteString> int32ToInt32Field_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, com.google.protobuf.ByteString>
    internalGetInt32ToInt32Field() {
      return int32ToInt32Field_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, com.google.protobuf.ByteString>
    internalGetMutableInt32ToInt32Field() {
      if (!int32ToInt32Field_.isMutable()) {
        int32ToInt32Field_ = int32ToInt32Field_.mutableCopy();
      }
      return int32ToInt32Field_;
    }
    @java.lang.Override

    public int getInt32ToInt32FieldCount() {
      return internalGetInt32ToInt32Field().size();
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToInt32Field(
        int key) {
      
      return internalGetInt32ToInt32Field().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToInt32FieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToInt32Field() {
      return getInt32ToInt32FieldMap();
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToInt32FieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToInt32Field());
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToInt32FieldOrDefault(
        int key,
        com.google.protobuf.ByteString defaultValue) {
      
      java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
          internalGetInt32ToInt32Field();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToInt32FieldOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
          internalGetInt32ToInt32Field();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
     */
    private java.util.Map<java.lang.Integer, com.google.protobuf.ByteString>
    getMutableInt32ToInt32FieldMap() {
      return internalGetMutableInt32ToInt32Field();
    }

    public static final int INT32_TO_STRING_FIELD_FIELD_NUMBER = 2;
    private static final class Int32ToStringFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> int32ToStringField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetInt32ToStringField() {
      return int32ToStringField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableInt32ToStringField() {
      if (!int32ToStringField_.isMutable()) {
        int32ToStringField_ = int32ToStringField_.mutableCopy();
      }
      return int32ToStringField_;
    }
    @java.lang.Override

    public int getInt32ToStringFieldCount() {
      return internalGetInt32ToStringField().size();
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToStringField(
        java.lang.String key) {
      key.getClass();
      return internalGetInt32ToStringField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToStringFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToStringField() {
      return getInt32ToStringFieldMap();
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToStringFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToStringField());
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public int getInt32ToStringFieldOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt32ToStringField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    @java.lang.Override

    public int getInt32ToStringFieldOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt32ToStringField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableInt32ToStringFieldMap() {
      return internalGetMutableInt32ToStringField();
    }

    public static final int INT32_TO_BYTES_FIELD_FIELD_NUMBER = 3;
    private static final class Int32ToBytesFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> int32ToBytesField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetInt32ToBytesField() {
      return int32ToBytesField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableInt32ToBytesField() {
      if (!int32ToBytesField_.isMutable()) {
        int32ToBytesField_ = int32ToBytesField_.mutableCopy();
      }
      return int32ToBytesField_;
    }
    @java.lang.Override

    public int getInt32ToBytesFieldCount() {
      return internalGetInt32ToBytesField().size();
    }
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToBytesField(
        java.lang.String key) {
      key.getClass();
      return internalGetInt32ToBytesField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToBytesFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToBytesField() {
      return getInt32ToBytesFieldMap();
    }
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToBytesFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToBytesField());
    }
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public int getInt32ToBytesFieldOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt32ToBytesField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    @java.lang.Override

    public int getInt32ToBytesFieldOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt32ToBytesField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * different key types, same value
     * </pre>
     *
     * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableInt32ToBytesFieldMap() {
      return internalGetMutableInt32ToBytesField();
    }

    public static final int INT32_TO_ENUM_FIELD_FIELD_NUMBER = 4;
    private static final class Int32ToEnumFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, com.google.protobuf.ByteString> int32ToEnumField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, com.google.protobuf.ByteString>
    internalGetInt32ToEnumField() {
      return int32ToEnumField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, com.google.protobuf.ByteString>
    internalGetMutableInt32ToEnumField() {
      if (!int32ToEnumField_.isMutable()) {
        int32ToEnumField_ = int32ToEnumField_.mutableCopy();
      }
      return int32ToEnumField_;
    }
    @java.lang.Override

    public int getInt32ToEnumFieldCount() {
      return internalGetInt32ToEnumField().size();
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToEnumField(
        java.lang.String key) {
      key.getClass();
      return internalGetInt32ToEnumField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToEnumFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToEnumField() {
      return getInt32ToEnumFieldMap();
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToEnumFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToEnumField());
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToEnumFieldOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetInt32ToEnumField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToEnumFieldOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetInt32ToEnumField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
     */
    private java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getMutableInt32ToEnumFieldMap() {
      return internalGetMutableInt32ToEnumField();
    }

    public static final int INT32_TO_MESSAGE_FIELD_FIELD_NUMBER = 5;
    private static final class Int32ToMessageFieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, com.google.protobuf.ByteString> int32ToMessageField_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, com.google.protobuf.ByteString>
    internalGetInt32ToMessageField() {
      return int32ToMessageField_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, com.google.protobuf.ByteString>
    internalGetMutableInt32ToMessageField() {
      if (!int32ToMessageField_.isMutable()) {
        int32ToMessageField_ = int32ToMessageField_.mutableCopy();
      }
      return int32ToMessageField_;
    }
    @java.lang.Override

    public int getInt32ToMessageFieldCount() {
      return internalGetInt32ToMessageField().size();
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public boolean containsInt32ToMessageField(
        java.lang.String key) {
      key.getClass();
      return internalGetInt32ToMessageField().containsKey(key);
    }
    /**
     * Use {@link #getInt32ToMessageFieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToMessageField() {
      return getInt32ToMessageFieldMap();
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToMessageFieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt32ToMessageField());
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToMessageFieldOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetInt32ToMessageField();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getInt32ToMessageFieldOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetInt32ToMessageField();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * different key and value types
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
     */
    private java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getMutableInt32ToMessageFieldMap() {
      return internalGetMutableInt32ToMessageField();
    }

    public static final int STRING_TO_INT32_FIELD_FIELD_NUMBER = 6;
    private static final class StringToInt32FieldDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, com.google.protobuf.ByteString>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, com.google.protobuf.ByteString> stringToInt32Field_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, com.google.protobuf.ByteString>
    internalGetStringToInt32Field() {
      return stringToInt32Field_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, com.google.protobuf.ByteString>
    internalGetMutableStringToInt32Field() {
      if (!stringToInt32Field_.isMutable()) {
        stringToInt32Field_ = stringToInt32Field_.mutableCopy();
      }
      return stringToInt32Field_;
    }
    @java.lang.Override

    public int getStringToInt32FieldCount() {
      return internalGetStringToInt32Field().size();
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public boolean containsStringToInt32Field(
        java.lang.String key) {
      key.getClass();
      return internalGetStringToInt32Field().containsKey(key);
    }
    /**
     * Use {@link #getStringToInt32FieldMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getStringToInt32Field() {
      return getStringToInt32FieldMap();
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getStringToInt32FieldMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetStringToInt32Field());
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getStringToInt32FieldOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetStringToInt32Field();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    @java.lang.Override

    public com.google.protobuf.ByteString getStringToInt32FieldOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetStringToInt32Field();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * same key type, different value
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
     */
    private java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getMutableStringToInt32FieldMap() {
      return internalGetMutableStringToInt32Field();
    }

    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.BizarroTestMap parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(map_test.MapForProto2TestProto.BizarroTestMap prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * a decoy of TestMap for testing parsing errors
     * </pre>
     *
     * Protobuf type {@code map_for_proto2_test.BizarroTestMap}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          map_test.MapForProto2TestProto.BizarroTestMap, Builder> implements
        // @@protoc_insertion_point(builder_implements:map_for_proto2_test.BizarroTestMap)
        map_test.MapForProto2TestProto.BizarroTestMapOrBuilder {
      // Construct using map_test.MapForProto2TestProto.BizarroTestMap.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getInt32ToInt32FieldCount() {
        return instance.getInt32ToInt32FieldMap().size();
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToInt32Field(
          int key) {
        
        return instance.getInt32ToInt32FieldMap().containsKey(key);
      }

      public Builder clearInt32ToInt32Field() {
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */

      public Builder removeInt32ToInt32Field(
          int key) {
        
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToInt32FieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToInt32Field() {
        return getInt32ToInt32FieldMap();
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> getInt32ToInt32FieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToInt32FieldMap());
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToInt32FieldOrDefault(
          int key,
          com.google.protobuf.ByteString defaultValue) {
        
        java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
            instance.getInt32ToInt32FieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToInt32FieldOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> map =
            instance.getInt32ToInt32FieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */
      public Builder putInt32ToInt32Field(
          int key,
          com.google.protobuf.ByteString value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;int32, bytes&gt; int32_to_int32_field = 1;</code>
       */
      public Builder putAllInt32ToInt32Field(
          java.util.Map<java.lang.Integer, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableInt32ToInt32FieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToStringFieldCount() {
        return instance.getInt32ToStringFieldMap().size();
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToStringField(
          java.lang.String key) {
        key.getClass();
        return instance.getInt32ToStringFieldMap().containsKey(key);
      }

      public Builder clearInt32ToStringField() {
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */

      public Builder removeInt32ToStringField(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToStringFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToStringField() {
        return getInt32ToStringFieldMap();
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToStringFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToStringFieldMap());
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override

      public int getInt32ToStringFieldOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getInt32ToStringFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */
      @java.lang.Override

      public int getInt32ToStringFieldOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getInt32ToStringFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */
      public Builder putInt32ToStringField(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_string_field = 2;</code>
       */
      public Builder putAllInt32ToStringField(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableInt32ToStringFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToBytesFieldCount() {
        return instance.getInt32ToBytesFieldMap().size();
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToBytesField(
          java.lang.String key) {
        key.getClass();
        return instance.getInt32ToBytesFieldMap().containsKey(key);
      }

      public Builder clearInt32ToBytesField() {
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */

      public Builder removeInt32ToBytesField(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToBytesFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToBytesField() {
        return getInt32ToBytesFieldMap();
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getInt32ToBytesFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToBytesFieldMap());
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override

      public int getInt32ToBytesFieldOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getInt32ToBytesFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */
      @java.lang.Override

      public int getInt32ToBytesFieldOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getInt32ToBytesFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */
      public Builder putInt32ToBytesField(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * different key types, same value
       * </pre>
       *
       * <code>map&lt;string, int32&gt; int32_to_bytes_field = 3;</code>
       */
      public Builder putAllInt32ToBytesField(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableInt32ToBytesFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToEnumFieldCount() {
        return instance.getInt32ToEnumFieldMap().size();
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToEnumField(
          java.lang.String key) {
        key.getClass();
        return instance.getInt32ToEnumFieldMap().containsKey(key);
      }

      public Builder clearInt32ToEnumField() {
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */

      public Builder removeInt32ToEnumField(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToEnumFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToEnumField() {
        return getInt32ToEnumFieldMap();
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToEnumFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToEnumFieldMap());
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToEnumFieldOrDefault(
          java.lang.String key,
          com.google.protobuf.ByteString defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            instance.getInt32ToEnumFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToEnumFieldOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            instance.getInt32ToEnumFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */
      public Builder putInt32ToEnumField(
          java.lang.String key,
          com.google.protobuf.ByteString value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_enum_field = 4;</code>
       */
      public Builder putAllInt32ToEnumField(
          java.util.Map<java.lang.String, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableInt32ToEnumFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getInt32ToMessageFieldCount() {
        return instance.getInt32ToMessageFieldMap().size();
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override

      public boolean containsInt32ToMessageField(
          java.lang.String key) {
        key.getClass();
        return instance.getInt32ToMessageFieldMap().containsKey(key);
      }

      public Builder clearInt32ToMessageField() {
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */

      public Builder removeInt32ToMessageField(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getInt32ToMessageFieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToMessageField() {
        return getInt32ToMessageFieldMap();
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInt32ToMessageFieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getInt32ToMessageFieldMap());
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToMessageFieldOrDefault(
          java.lang.String key,
          com.google.protobuf.ByteString defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            instance.getInt32ToMessageFieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getInt32ToMessageFieldOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            instance.getInt32ToMessageFieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */
      public Builder putInt32ToMessageField(
          java.lang.String key,
          com.google.protobuf.ByteString value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * different key and value types
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; int32_to_message_field = 5;</code>
       */
      public Builder putAllInt32ToMessageField(
          java.util.Map<java.lang.String, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableInt32ToMessageFieldMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getStringToInt32FieldCount() {
        return instance.getStringToInt32FieldMap().size();
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override

      public boolean containsStringToInt32Field(
          java.lang.String key) {
        key.getClass();
        return instance.getStringToInt32FieldMap().containsKey(key);
      }

      public Builder clearStringToInt32Field() {
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().clear();
        return this;
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */

      public Builder removeStringToInt32Field(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getStringToInt32FieldMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getStringToInt32Field() {
        return getStringToInt32FieldMap();
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getStringToInt32FieldMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getStringToInt32FieldMap());
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getStringToInt32FieldOrDefault(
          java.lang.String key,
          com.google.protobuf.ByteString defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            instance.getStringToInt32FieldMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */
      @java.lang.Override

      public com.google.protobuf.ByteString getStringToInt32FieldOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            instance.getStringToInt32FieldMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */
      public Builder putStringToInt32Field(
          java.lang.String key,
          com.google.protobuf.ByteString value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * same key type, different value
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; string_to_int32_field = 6;</code>
       */
      public Builder putAllStringToInt32Field(
          java.util.Map<java.lang.String, com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.getMutableStringToInt32FieldMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:map_for_proto2_test.BizarroTestMap)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new map_test.MapForProto2TestProto.BizarroTestMap();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "int32ToInt32Field_",
              Int32ToInt32FieldDefaultEntryHolder.defaultEntry,
              "int32ToStringField_",
              Int32ToStringFieldDefaultEntryHolder.defaultEntry,
              "int32ToBytesField_",
              Int32ToBytesFieldDefaultEntryHolder.defaultEntry,
              "int32ToEnumField_",
              Int32ToEnumFieldDefaultEntryHolder.defaultEntry,
              "int32ToMessageField_",
              Int32ToMessageFieldDefaultEntryHolder.defaultEntry,
              "stringToInt32Field_",
              StringToInt32FieldDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0000\u0001\u0006\u0006\u0006\u0000\u0000\u00012\u00022\u0003" +
                "2\u00042\u00052\u00062";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<map_test.MapForProto2TestProto.BizarroTestMap> parser = PARSER;
          if (parser == null) {
            synchronized (map_test.MapForProto2TestProto.BizarroTestMap.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.BizarroTestMap>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:map_for_proto2_test.BizarroTestMap)
    private static final map_test.MapForProto2TestProto.BizarroTestMap DEFAULT_INSTANCE;
    static {
      BizarroTestMap defaultInstance = new BizarroTestMap();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BizarroTestMap.class, defaultInstance);
    }

    public static map_test.MapForProto2TestProto.BizarroTestMap getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BizarroTestMap> PARSER;

    public static com.google.protobuf.Parser<BizarroTestMap> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ReservedAsMapFieldOrBuilder extends
      // @@protoc_insertion_point(interface_extends:map_for_proto2_test.ReservedAsMapField)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    int getIfCount();
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    boolean containsIf(
        java.lang.String key);
    /**
     * Use {@link #getIfMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getIf();
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getIfMap();
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */

    int getIfOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */

    int getIfOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    int getConstCount();
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    boolean containsConst(
        java.lang.String key);
    /**
     * Use {@link #getConstMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getConst();
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getConstMap();
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */

    int getConstOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */

    int getConstOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    int getPrivateCount();
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    boolean containsPrivate(
        java.lang.String key);
    /**
     * Use {@link #getPrivateMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getPrivate();
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getPrivateMap();
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */

    int getPrivateOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */

    int getPrivateOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    int getClass_Count();
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    boolean containsClass_(
        java.lang.String key);
    /**
     * Use {@link #getClass_Map()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getClass_();
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getClass_Map();
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */

    int getClass_OrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */

    int getClass_OrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    int getIntCount();
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    boolean containsInt(
        java.lang.String key);
    /**
     * Use {@link #getIntMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getInt();
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getIntMap();
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */

    int getIntOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */

    int getIntOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    int getVoidCount();
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    boolean containsVoid(
        java.lang.String key);
    /**
     * Use {@link #getVoidMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getVoid();
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getVoidMap();
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */

    int getVoidOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */

    int getVoidOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    int getStringCount();
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    boolean containsString(
        java.lang.String key);
    /**
     * Use {@link #getStringMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getString();
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getStringMap();
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */

    int getStringOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */

    int getStringOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    int getPackageCount();
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    boolean containsPackage(
        java.lang.String key);
    /**
     * Use {@link #getPackageMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getPackage();
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getPackageMap();
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */

    int getPackageOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */

    int getPackageOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    int getEnumCount();
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    boolean containsEnum(
        java.lang.String key);
    /**
     * Use {@link #getEnumMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getEnum();
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getEnumMap();
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */

    int getEnumOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */

    int getEnumOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    int getNullCount();
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    boolean containsNull(
        java.lang.String key);
    /**
     * Use {@link #getNullMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Integer>
    getNull();
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    java.util.Map<java.lang.String, java.lang.Integer>
    getNullMap();
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */

    int getNullOrDefault(
        java.lang.String key,
        int defaultValue);
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */

    int getNullOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * Used to test that java reserved words can be used as protobuf field names
   * Not all reserved words are tested (to avoid bloat) but instead an arbitrary
   * subset of them chosen to cover various keyword categories like
   * type, modifier, declaration, etc.
   * </pre>
   *
   * Protobuf type {@code map_for_proto2_test.ReservedAsMapField}
   */
  public  static final class ReservedAsMapField extends
      com.google.protobuf.GeneratedMessageLite<
          ReservedAsMapField, ReservedAsMapField.Builder> implements
      // @@protoc_insertion_point(message_implements:map_for_proto2_test.ReservedAsMapField)
      ReservedAsMapFieldOrBuilder {
    private ReservedAsMapField() {
    }
    public static final int IF_FIELD_NUMBER = 1;
    private static final class IfDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> if_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetIf() {
      return if_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableIf() {
      if (!if_.isMutable()) {
        if_ = if_.mutableCopy();
      }
      return if_;
    }
    @java.lang.Override

    public int getIfCount() {
      return internalGetIf().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    @java.lang.Override

    public boolean containsIf(
        java.lang.String key) {
      key.getClass();
      return internalGetIf().containsKey(key);
    }
    /**
     * Use {@link #getIfMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getIf() {
      return getIfMap();
    }
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getIfMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetIf());
    }
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    @java.lang.Override

    public int getIfOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetIf();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    @java.lang.Override

    public int getIfOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetIf();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; if = 1;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableIfMap() {
      return internalGetMutableIf();
    }

    public static final int CONST_FIELD_NUMBER = 2;
    private static final class ConstDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> const_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetConst() {
      return const_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableConst() {
      if (!const_.isMutable()) {
        const_ = const_.mutableCopy();
      }
      return const_;
    }
    @java.lang.Override

    public int getConstCount() {
      return internalGetConst().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    @java.lang.Override

    public boolean containsConst(
        java.lang.String key) {
      key.getClass();
      return internalGetConst().containsKey(key);
    }
    /**
     * Use {@link #getConstMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getConst() {
      return getConstMap();
    }
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getConstMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetConst());
    }
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    @java.lang.Override

    public int getConstOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetConst();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    @java.lang.Override

    public int getConstOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetConst();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; const = 2;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableConstMap() {
      return internalGetMutableConst();
    }

    public static final int PRIVATE_FIELD_NUMBER = 3;
    private static final class PrivateDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> private_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetPrivate() {
      return private_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutablePrivate() {
      if (!private_.isMutable()) {
        private_ = private_.mutableCopy();
      }
      return private_;
    }
    @java.lang.Override

    public int getPrivateCount() {
      return internalGetPrivate().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    @java.lang.Override

    public boolean containsPrivate(
        java.lang.String key) {
      key.getClass();
      return internalGetPrivate().containsKey(key);
    }
    /**
     * Use {@link #getPrivateMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getPrivate() {
      return getPrivateMap();
    }
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getPrivateMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetPrivate());
    }
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    @java.lang.Override

    public int getPrivateOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPrivate();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    @java.lang.Override

    public int getPrivateOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPrivate();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; private = 3;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutablePrivateMap() {
      return internalGetMutablePrivate();
    }

    public static final int CLASS_FIELD_NUMBER = 4;
    private static final class Class_DefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> class__ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetClass_() {
      return class__;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableClass_() {
      if (!class__.isMutable()) {
        class__ = class__.mutableCopy();
      }
      return class__;
    }
    @java.lang.Override

    public int getClass_Count() {
      return internalGetClass_().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    @java.lang.Override

    public boolean containsClass_(
        java.lang.String key) {
      key.getClass();
      return internalGetClass_().containsKey(key);
    }
    /**
     * Use {@link #getClass_Map()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getClass_() {
      return getClass_Map();
    }
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getClass_Map() {
      return java.util.Collections.unmodifiableMap(
          internalGetClass_());
    }
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    @java.lang.Override

    public int getClass_OrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetClass_();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    @java.lang.Override

    public int getClass_OrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetClass_();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; class = 4;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableClass_Map() {
      return internalGetMutableClass_();
    }

    public static final int INT_FIELD_NUMBER = 5;
    private static final class IntDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> int_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetInt() {
      return int_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableInt() {
      if (!int_.isMutable()) {
        int_ = int_.mutableCopy();
      }
      return int_;
    }
    @java.lang.Override

    public int getIntCount() {
      return internalGetInt().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    @java.lang.Override

    public boolean containsInt(
        java.lang.String key) {
      key.getClass();
      return internalGetInt().containsKey(key);
    }
    /**
     * Use {@link #getIntMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getInt() {
      return getIntMap();
    }
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getIntMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetInt());
    }
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    @java.lang.Override

    public int getIntOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    @java.lang.Override

    public int getIntOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; int = 5;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableIntMap() {
      return internalGetMutableInt();
    }

    public static final int VOID_FIELD_NUMBER = 6;
    private static final class VoidDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> void_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetVoid() {
      return void_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableVoid() {
      if (!void_.isMutable()) {
        void_ = void_.mutableCopy();
      }
      return void_;
    }
    @java.lang.Override

    public int getVoidCount() {
      return internalGetVoid().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    @java.lang.Override

    public boolean containsVoid(
        java.lang.String key) {
      key.getClass();
      return internalGetVoid().containsKey(key);
    }
    /**
     * Use {@link #getVoidMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getVoid() {
      return getVoidMap();
    }
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getVoidMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetVoid());
    }
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    @java.lang.Override

    public int getVoidOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetVoid();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    @java.lang.Override

    public int getVoidOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetVoid();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; void = 6;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableVoidMap() {
      return internalGetMutableVoid();
    }

    public static final int STRING_FIELD_NUMBER = 7;
    private static final class StringDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> string_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetString() {
      return string_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableString() {
      if (!string_.isMutable()) {
        string_ = string_.mutableCopy();
      }
      return string_;
    }
    @java.lang.Override

    public int getStringCount() {
      return internalGetString().size();
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    @java.lang.Override

    public boolean containsString(
        java.lang.String key) {
      key.getClass();
      return internalGetString().containsKey(key);
    }
    /**
     * Use {@link #getStringMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getString() {
      return getStringMap();
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getStringMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetString());
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    @java.lang.Override

    public int getStringOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetString();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    @java.lang.Override

    public int getStringOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetString();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; string = 7;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableStringMap() {
      return internalGetMutableString();
    }

    public static final int PACKAGE_FIELD_NUMBER = 8;
    private static final class PackageDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> package_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetPackage() {
      return package_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutablePackage() {
      if (!package_.isMutable()) {
        package_ = package_.mutableCopy();
      }
      return package_;
    }
    @java.lang.Override

    public int getPackageCount() {
      return internalGetPackage().size();
    }
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    @java.lang.Override

    public boolean containsPackage(
        java.lang.String key) {
      key.getClass();
      return internalGetPackage().containsKey(key);
    }
    /**
     * Use {@link #getPackageMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getPackage() {
      return getPackageMap();
    }
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getPackageMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetPackage());
    }
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    @java.lang.Override

    public int getPackageOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPackage();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    @java.lang.Override

    public int getPackageOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPackage();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <code>map&lt;string, uint32&gt; package = 8;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutablePackageMap() {
      return internalGetMutablePackage();
    }

    public static final int ENUM_FIELD_NUMBER = 9;
    private static final class EnumDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> enum_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetEnum() {
      return enum_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableEnum() {
      if (!enum_.isMutable()) {
        enum_ = enum_.mutableCopy();
      }
      return enum_;
    }
    @java.lang.Override

    public int getEnumCount() {
      return internalGetEnum().size();
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    @java.lang.Override

    public boolean containsEnum(
        java.lang.String key) {
      key.getClass();
      return internalGetEnum().containsKey(key);
    }
    /**
     * Use {@link #getEnumMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getEnum() {
      return getEnumMap();
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getEnumMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetEnum());
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    @java.lang.Override

    public int getEnumOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetEnum();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    @java.lang.Override

    public int getEnumOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetEnum();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; enum = 9;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableEnumMap() {
      return internalGetMutableEnum();
    }

    public static final int NULL_FIELD_NUMBER = 10;
    private static final class NullDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0);
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> null_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetNull() {
      return null_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableNull() {
      if (!null_.isMutable()) {
        null_ = null_.mutableCopy();
      }
      return null_;
    }
    @java.lang.Override

    public int getNullCount() {
      return internalGetNull().size();
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    @java.lang.Override

    public boolean containsNull(
        java.lang.String key) {
      key.getClass();
      return internalGetNull().containsKey(key);
    }
    /**
     * Use {@link #getNullMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Integer> getNull() {
      return getNullMap();
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Integer> getNullMap() {
      return java.util.Collections.unmodifiableMap(
          internalGetNull());
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    @java.lang.Override

    public int getNullOrDefault(
        java.lang.String key,
        int defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetNull();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    @java.lang.Override

    public int getNullOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetNull();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, uint32&gt; null = 10;</code>
     */
    private java.util.Map<java.lang.String, java.lang.Integer>
    getMutableNullMap() {
      return internalGetMutableNull();
    }

    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapField parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(map_test.MapForProto2TestProto.ReservedAsMapField prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Used to test that java reserved words can be used as protobuf field names
     * Not all reserved words are tested (to avoid bloat) but instead an arbitrary
     * subset of them chosen to cover various keyword categories like
     * type, modifier, declaration, etc.
     * </pre>
     *
     * Protobuf type {@code map_for_proto2_test.ReservedAsMapField}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          map_test.MapForProto2TestProto.ReservedAsMapField, Builder> implements
        // @@protoc_insertion_point(builder_implements:map_for_proto2_test.ReservedAsMapField)
        map_test.MapForProto2TestProto.ReservedAsMapFieldOrBuilder {
      // Construct using map_test.MapForProto2TestProto.ReservedAsMapField.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getIfCount() {
        return instance.getIfMap().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */
      @java.lang.Override

      public boolean containsIf(
          java.lang.String key) {
        key.getClass();
        return instance.getIfMap().containsKey(key);
      }

      public Builder clearIf() {
        copyOnWrite();
        instance.getMutableIfMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */

      public Builder removeIf(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableIfMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getIfMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getIf() {
        return getIfMap();
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getIfMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getIfMap());
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */
      @java.lang.Override

      public int getIfOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getIfMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */
      @java.lang.Override

      public int getIfOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getIfMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */
      public Builder putIf(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableIfMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; if = 1;</code>
       */
      public Builder putAllIf(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableIfMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getConstCount() {
        return instance.getConstMap().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */
      @java.lang.Override

      public boolean containsConst(
          java.lang.String key) {
        key.getClass();
        return instance.getConstMap().containsKey(key);
      }

      public Builder clearConst() {
        copyOnWrite();
        instance.getMutableConstMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */

      public Builder removeConst(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableConstMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getConstMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getConst() {
        return getConstMap();
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getConstMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getConstMap());
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */
      @java.lang.Override

      public int getConstOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getConstMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */
      @java.lang.Override

      public int getConstOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getConstMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */
      public Builder putConst(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableConstMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; const = 2;</code>
       */
      public Builder putAllConst(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableConstMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getPrivateCount() {
        return instance.getPrivateMap().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */
      @java.lang.Override

      public boolean containsPrivate(
          java.lang.String key) {
        key.getClass();
        return instance.getPrivateMap().containsKey(key);
      }

      public Builder clearPrivate() {
        copyOnWrite();
        instance.getMutablePrivateMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */

      public Builder removePrivate(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutablePrivateMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getPrivateMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getPrivate() {
        return getPrivateMap();
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getPrivateMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getPrivateMap());
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */
      @java.lang.Override

      public int getPrivateOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getPrivateMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */
      @java.lang.Override

      public int getPrivateOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getPrivateMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */
      public Builder putPrivate(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutablePrivateMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; private = 3;</code>
       */
      public Builder putAllPrivate(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutablePrivateMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getClass_Count() {
        return instance.getClass_Map().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */
      @java.lang.Override

      public boolean containsClass_(
          java.lang.String key) {
        key.getClass();
        return instance.getClass_Map().containsKey(key);
      }

      public Builder clearClass_() {
        copyOnWrite();
        instance.getMutableClass_Map().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */

      public Builder removeClass_(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableClass_Map().remove(key);
        return this;
      }
      /**
       * Use {@link #getClass_Map()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getClass_() {
        return getClass_Map();
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getClass_Map() {
        return java.util.Collections.unmodifiableMap(
            instance.getClass_Map());
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */
      @java.lang.Override

      public int getClass_OrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getClass_Map();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */
      @java.lang.Override

      public int getClass_OrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getClass_Map();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */
      public Builder putClass_(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableClass_Map().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; class = 4;</code>
       */
      public Builder putAllClass_(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableClass_Map().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getIntCount() {
        return instance.getIntMap().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */
      @java.lang.Override

      public boolean containsInt(
          java.lang.String key) {
        key.getClass();
        return instance.getIntMap().containsKey(key);
      }

      public Builder clearInt() {
        copyOnWrite();
        instance.getMutableIntMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */

      public Builder removeInt(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableIntMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getIntMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getInt() {
        return getIntMap();
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getIntMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getIntMap());
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */
      @java.lang.Override

      public int getIntOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getIntMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */
      @java.lang.Override

      public int getIntOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getIntMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */
      public Builder putInt(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableIntMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; int = 5;</code>
       */
      public Builder putAllInt(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableIntMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getVoidCount() {
        return instance.getVoidMap().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */
      @java.lang.Override

      public boolean containsVoid(
          java.lang.String key) {
        key.getClass();
        return instance.getVoidMap().containsKey(key);
      }

      public Builder clearVoid() {
        copyOnWrite();
        instance.getMutableVoidMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */

      public Builder removeVoid(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableVoidMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getVoidMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getVoid() {
        return getVoidMap();
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getVoidMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getVoidMap());
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */
      @java.lang.Override

      public int getVoidOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getVoidMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */
      @java.lang.Override

      public int getVoidOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getVoidMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */
      public Builder putVoid(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableVoidMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; void = 6;</code>
       */
      public Builder putAllVoid(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableVoidMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getStringCount() {
        return instance.getStringMap().size();
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */
      @java.lang.Override

      public boolean containsString(
          java.lang.String key) {
        key.getClass();
        return instance.getStringMap().containsKey(key);
      }

      public Builder clearString() {
        copyOnWrite();
        instance.getMutableStringMap().clear();
        return this;
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */

      public Builder removeString(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableStringMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getStringMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getString() {
        return getStringMap();
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getStringMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getStringMap());
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */
      @java.lang.Override

      public int getStringOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getStringMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */
      @java.lang.Override

      public int getStringOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getStringMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */
      public Builder putString(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableStringMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; string = 7;</code>
       */
      public Builder putAllString(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableStringMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getPackageCount() {
        return instance.getPackageMap().size();
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */
      @java.lang.Override

      public boolean containsPackage(
          java.lang.String key) {
        key.getClass();
        return instance.getPackageMap().containsKey(key);
      }

      public Builder clearPackage() {
        copyOnWrite();
        instance.getMutablePackageMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */

      public Builder removePackage(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutablePackageMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getPackageMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getPackage() {
        return getPackageMap();
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getPackageMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getPackageMap());
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */
      @java.lang.Override

      public int getPackageOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getPackageMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */
      @java.lang.Override

      public int getPackageOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getPackageMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */
      public Builder putPackage(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutablePackageMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, uint32&gt; package = 8;</code>
       */
      public Builder putAllPackage(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutablePackageMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getEnumCount() {
        return instance.getEnumMap().size();
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */
      @java.lang.Override

      public boolean containsEnum(
          java.lang.String key) {
        key.getClass();
        return instance.getEnumMap().containsKey(key);
      }

      public Builder clearEnum() {
        copyOnWrite();
        instance.getMutableEnumMap().clear();
        return this;
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */

      public Builder removeEnum(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableEnumMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getEnumMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getEnum() {
        return getEnumMap();
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getEnumMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getEnumMap());
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */
      @java.lang.Override

      public int getEnumOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getEnumMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */
      @java.lang.Override

      public int getEnumOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getEnumMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */
      public Builder putEnum(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableEnumMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; enum = 9;</code>
       */
      public Builder putAllEnum(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableEnumMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getNullCount() {
        return instance.getNullMap().size();
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */
      @java.lang.Override

      public boolean containsNull(
          java.lang.String key) {
        key.getClass();
        return instance.getNullMap().containsKey(key);
      }

      public Builder clearNull() {
        copyOnWrite();
        instance.getMutableNullMap().clear();
        return this;
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */

      public Builder removeNull(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableNullMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getNullMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Integer> getNull() {
        return getNullMap();
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.Integer> getNullMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getNullMap());
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */
      @java.lang.Override

      public int getNullOrDefault(
          java.lang.String key,
          int defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getNullMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */
      @java.lang.Override

      public int getNullOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, java.lang.Integer> map =
            instance.getNullMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */
      public Builder putNull(
          java.lang.String key,
          int value) {
        key.getClass();
        
        copyOnWrite();
        instance.getMutableNullMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, uint32&gt; null = 10;</code>
       */
      public Builder putAllNull(
          java.util.Map<java.lang.String, java.lang.Integer> values) {
        copyOnWrite();
        instance.getMutableNullMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:map_for_proto2_test.ReservedAsMapField)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new map_test.MapForProto2TestProto.ReservedAsMapField();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "if_",
              IfDefaultEntryHolder.defaultEntry,
              "const_",
              ConstDefaultEntryHolder.defaultEntry,
              "private_",
              PrivateDefaultEntryHolder.defaultEntry,
              "class__",
              Class_DefaultEntryHolder.defaultEntry,
              "int_",
              IntDefaultEntryHolder.defaultEntry,
              "void_",
              VoidDefaultEntryHolder.defaultEntry,
              "string_",
              StringDefaultEntryHolder.defaultEntry,
              "package_",
              PackageDefaultEntryHolder.defaultEntry,
              "enum_",
              EnumDefaultEntryHolder.defaultEntry,
              "null_",
              NullDefaultEntryHolder.defaultEntry,
            };
            java.lang.String info =
                "\u0001\n\u0000\u0000\u0001\n\n\n\u0000\u0000\u00012\u00022\u00032\u00042\u00052\u0006" +
                "2\u00072\b2\t2\n2";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<map_test.MapForProto2TestProto.ReservedAsMapField> parser = PARSER;
          if (parser == null) {
            synchronized (map_test.MapForProto2TestProto.ReservedAsMapField.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.ReservedAsMapField>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:map_for_proto2_test.ReservedAsMapField)
    private static final map_test.MapForProto2TestProto.ReservedAsMapField DEFAULT_INSTANCE;
    static {
      ReservedAsMapField defaultInstance = new ReservedAsMapField();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ReservedAsMapField.class, defaultInstance);
    }

    public static map_test.MapForProto2TestProto.ReservedAsMapField getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ReservedAsMapField> PARSER;

    public static com.google.protobuf.Parser<ReservedAsMapField> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ReservedAsMapFieldWithEnumValueOrBuilder extends
      // @@protoc_insertion_point(interface_extends:map_for_proto2_test.ReservedAsMapFieldWithEnumValue)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    int getIfCount();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    boolean containsIf(
        java.lang.String key);
    /**
     * Use {@link #getIfMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getIf();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getIfMap();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIfOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIfOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    int getConstCount();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    boolean containsConst(
        java.lang.String key);
    /**
     * Use {@link #getConstMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getConst();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getConstMap();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getConstOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getConstOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    int getPrivateCount();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    boolean containsPrivate(
        java.lang.String key);
    /**
     * Use {@link #getPrivateMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPrivate();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPrivateMap();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPrivateOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPrivateOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    int getClass_Count();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    boolean containsClass_(
        java.lang.String key);
    /**
     * Use {@link #getClass_Map()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getClass_();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getClass_Map();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getClass_OrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getClass_OrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    int getIntCount();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    boolean containsInt(
        java.lang.String key);
    /**
     * Use {@link #getIntMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getInt();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getIntMap();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIntOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIntOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    int getVoidCount();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    boolean containsVoid(
        java.lang.String key);
    /**
     * Use {@link #getVoidMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getVoid();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getVoidMap();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getVoidOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getVoidOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    int getStringCount();
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    boolean containsString(
        java.lang.String key);
    /**
     * Use {@link #getStringMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getString();
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getStringMap();
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getStringOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getStringOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    int getPackageCount();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    boolean containsPackage(
        java.lang.String key);
    /**
     * Use {@link #getPackageMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPackage();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPackageMap();
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPackageOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPackageOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    int getEnumCount();
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    boolean containsEnum(
        java.lang.String key);
    /**
     * Use {@link #getEnumMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getEnum();
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getEnumMap();
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getEnumOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getEnumOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    int getNullCount();
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    boolean containsNull(
        java.lang.String key);
    /**
     * Use {@link #getNullMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getNull();
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getNullMap();
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getNullOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue);
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getNullOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code map_for_proto2_test.ReservedAsMapFieldWithEnumValue}
   */
  public  static final class ReservedAsMapFieldWithEnumValue extends
      com.google.protobuf.GeneratedMessageLite<
          ReservedAsMapFieldWithEnumValue, ReservedAsMapFieldWithEnumValue.Builder> implements
      // @@protoc_insertion_point(message_implements:map_for_proto2_test.ReservedAsMapFieldWithEnumValue)
      ReservedAsMapFieldWithEnumValueOrBuilder {
    private ReservedAsMapFieldWithEnumValue() {
    }
    /**
     * Protobuf enum {@code map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum}
     */
    public enum SampleEnum
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>A = 0;</code>
       */
      A(0),
      /**
       * <code>B = 1;</code>
       */
      B(1),
      ;

      /**
       * <code>A = 0;</code>
       */
      public static final int A_VALUE = 0;
      /**
       * <code>B = 1;</code>
       */
      public static final int B_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SampleEnum valueOf(int value) {
        return forNumber(value);
      }

      public static SampleEnum forNumber(int value) {
        switch (value) {
          case 0: return A;
          case 1: return B;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SampleEnum>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SampleEnum> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SampleEnum>() {
              @java.lang.Override
              public SampleEnum findValueByNumber(int number) {
                return SampleEnum.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return SampleEnumVerifier.INSTANCE;
      }

      private static final class SampleEnumVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SampleEnumVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return SampleEnum.forNumber(number) != null;
              }
            };

      private final int value;

      private SampleEnum(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum)
    }

    public static final int IF_FIELD_NUMBER = 1;
    private static final class IfDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> if_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetIf() {
      return if_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableIf() {
      if (!if_.isMutable()) {
        if_ = if_.mutableCopy();
      }
      return if_;
    }
    @java.lang.Override

    public int getIfCount() {
      return internalGetIf().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    @java.lang.Override

    public boolean containsIf(
        java.lang.String key) {
      key.getClass();
      return internalGetIf().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> ifValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getIfMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getIf() {
      return getIfMap();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getIfMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetIf(),
                ifValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIfOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetIf();
      return map.containsKey(key)
             ? ifValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIfOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetIf();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return ifValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableIfMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableIf(),
              ifValueConverter);
    }

    public static final int CONST_FIELD_NUMBER = 2;
    private static final class ConstDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> const_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetConst() {
      return const_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableConst() {
      if (!const_.isMutable()) {
        const_ = const_.mutableCopy();
      }
      return const_;
    }
    @java.lang.Override

    public int getConstCount() {
      return internalGetConst().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    @java.lang.Override

    public boolean containsConst(
        java.lang.String key) {
      key.getClass();
      return internalGetConst().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> constValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getConstMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getConst() {
      return getConstMap();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getConstMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetConst(),
                constValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getConstOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetConst();
      return map.containsKey(key)
             ? constValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getConstOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetConst();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return constValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableConstMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableConst(),
              constValueConverter);
    }

    public static final int PRIVATE_FIELD_NUMBER = 3;
    private static final class PrivateDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> private_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetPrivate() {
      return private_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutablePrivate() {
      if (!private_.isMutable()) {
        private_ = private_.mutableCopy();
      }
      return private_;
    }
    @java.lang.Override

    public int getPrivateCount() {
      return internalGetPrivate().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    @java.lang.Override

    public boolean containsPrivate(
        java.lang.String key) {
      key.getClass();
      return internalGetPrivate().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> privateValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getPrivateMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPrivate() {
      return getPrivateMap();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPrivateMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetPrivate(),
                privateValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPrivateOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPrivate();
      return map.containsKey(key)
             ? privateValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPrivateOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPrivate();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return privateValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutablePrivateMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutablePrivate(),
              privateValueConverter);
    }

    public static final int CLASS_FIELD_NUMBER = 4;
    private static final class Class_DefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> class__ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetClass_() {
      return class__;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableClass_() {
      if (!class__.isMutable()) {
        class__ = class__.mutableCopy();
      }
      return class__;
    }
    @java.lang.Override

    public int getClass_Count() {
      return internalGetClass_().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    @java.lang.Override

    public boolean containsClass_(
        java.lang.String key) {
      key.getClass();
      return internalGetClass_().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> class_ValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getClass_Map()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getClass_() {
      return getClass_Map();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getClass_Map() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetClass_(),
                class_ValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getClass_OrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetClass_();
      return map.containsKey(key)
             ? class_ValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getClass_OrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetClass_();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return class_ValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableClass_Map() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableClass_(),
              class_ValueConverter);
    }

    public static final int INT_FIELD_NUMBER = 5;
    private static final class IntDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> int_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetInt() {
      return int_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableInt() {
      if (!int_.isMutable()) {
        int_ = int_.mutableCopy();
      }
      return int_;
    }
    @java.lang.Override

    public int getIntCount() {
      return internalGetInt().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    @java.lang.Override

    public boolean containsInt(
        java.lang.String key) {
      key.getClass();
      return internalGetInt().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> intValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getIntMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getInt() {
      return getIntMap();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getIntMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetInt(),
                intValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIntOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt();
      return map.containsKey(key)
             ? intValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIntOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetInt();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return intValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableIntMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableInt(),
              intValueConverter);
    }

    public static final int VOID_FIELD_NUMBER = 6;
    private static final class VoidDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> void_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetVoid() {
      return void_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableVoid() {
      if (!void_.isMutable()) {
        void_ = void_.mutableCopy();
      }
      return void_;
    }
    @java.lang.Override

    public int getVoidCount() {
      return internalGetVoid().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    @java.lang.Override

    public boolean containsVoid(
        java.lang.String key) {
      key.getClass();
      return internalGetVoid().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> voidValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getVoidMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getVoid() {
      return getVoidMap();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getVoidMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetVoid(),
                voidValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getVoidOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetVoid();
      return map.containsKey(key)
             ? voidValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getVoidOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetVoid();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return voidValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableVoidMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableVoid(),
              voidValueConverter);
    }

    public static final int STRING_FIELD_NUMBER = 7;
    private static final class StringDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> string_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetString() {
      return string_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableString() {
      if (!string_.isMutable()) {
        string_ = string_.mutableCopy();
      }
      return string_;
    }
    @java.lang.Override

    public int getStringCount() {
      return internalGetString().size();
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    @java.lang.Override

    public boolean containsString(
        java.lang.String key) {
      key.getClass();
      return internalGetString().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> stringValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getStringMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getString() {
      return getStringMap();
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getStringMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetString(),
                stringValueConverter));
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getStringOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetString();
      return map.containsKey(key)
             ? stringValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getStringOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetString();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return stringValueConverter.doForward(map.get(key));
    }
    /**
     * <pre>
     * These are also proto keywords
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableStringMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableString(),
              stringValueConverter);
    }

    public static final int PACKAGE_FIELD_NUMBER = 8;
    private static final class PackageDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> package_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetPackage() {
      return package_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutablePackage() {
      if (!package_.isMutable()) {
        package_ = package_.mutableCopy();
      }
      return package_;
    }
    @java.lang.Override

    public int getPackageCount() {
      return internalGetPackage().size();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    @java.lang.Override

    public boolean containsPackage(
        java.lang.String key) {
      key.getClass();
      return internalGetPackage().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> packageValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getPackageMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPackage() {
      return getPackageMap();
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getPackageMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetPackage(),
                packageValueConverter));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPackageOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPackage();
      return map.containsKey(key)
             ? packageValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPackageOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetPackage();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return packageValueConverter.doForward(map.get(key));
    }
    /**
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutablePackageMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutablePackage(),
              packageValueConverter);
    }

    public static final int ENUM_FIELD_NUMBER = 9;
    private static final class EnumDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> enum_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetEnum() {
      return enum_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableEnum() {
      if (!enum_.isMutable()) {
        enum_ = enum_.mutableCopy();
      }
      return enum_;
    }
    @java.lang.Override

    public int getEnumCount() {
      return internalGetEnum().size();
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    @java.lang.Override

    public boolean containsEnum(
        java.lang.String key) {
      key.getClass();
      return internalGetEnum().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> enumValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getEnumMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getEnum() {
      return getEnumMap();
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getEnumMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetEnum(),
                enumValueConverter));
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getEnumOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetEnum();
      return map.containsKey(key)
             ? enumValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getEnumOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetEnum();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return enumValueConverter.doForward(map.get(key));
    }
    /**
     * <pre>
     * Most recent Java reserved word
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableEnumMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableEnum(),
              enumValueConverter);
    }

    public static final int NULL_FIELD_NUMBER = 10;
    private static final class NullDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.String, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.String, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.String, java.lang.Integer> null_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetNull() {
      return null_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.Integer>
    internalGetMutableNull() {
      if (!null_.isMutable()) {
        null_ = null_.mutableCopy();
      }
      return null_;
    }
    @java.lang.Override

    public int getNullCount() {
      return internalGetNull().size();
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    @java.lang.Override

    public boolean containsNull(
        java.lang.String key) {
      key.getClass();
      return internalGetNull().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> nullValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetValueMap(),
                map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.A);
    /**
     * Use {@link #getNullMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getNull() {
      return getNullMap();
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getNullMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
                internalGetNull(),
                nullValueConverter));
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getNullOrDefault(
        java.lang.String key,
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetNull();
      return map.containsKey(key)
             ? nullValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    @java.lang.Override

    public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getNullOrThrow(
        java.lang.String key) {
      key.getClass();
      java.util.Map<java.lang.String, java.lang.Integer> map =
          internalGetNull();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return nullValueConverter.doForward(map.get(key));
    }
    /**
     * <pre>
     * null is not a 'reserved word' per se but as a literal needs similar care
     * </pre>
     *
     * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
     */
    private java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
    getMutableNullMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum, java.lang.Integer>(
              internalGetMutableNull(),
              nullValueConverter);
    }

    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code map_for_proto2_test.ReservedAsMapFieldWithEnumValue}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue, Builder> implements
        // @@protoc_insertion_point(builder_implements:map_for_proto2_test.ReservedAsMapFieldWithEnumValue)
        map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValueOrBuilder {
      // Construct using map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      @java.lang.Override

      public int getIfCount() {
        return instance.getIfMap().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */
      @java.lang.Override

      public boolean containsIf(
          java.lang.String key) {
        key.getClass();
        return instance.getIfMap().containsKey(key);
      }

      public Builder clearIf() {
        copyOnWrite();
        instance.getMutableIfMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */

      public Builder removeIf(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableIfMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getIfMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getIf() {
        return getIfMap();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getIfMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getIfMap());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIfOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getIfMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIfOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getIfMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */
      public Builder putIf(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableIfMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; if = 1;</code>
       */
      public Builder putAllIf(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableIfMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getConstCount() {
        return instance.getConstMap().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */
      @java.lang.Override

      public boolean containsConst(
          java.lang.String key) {
        key.getClass();
        return instance.getConstMap().containsKey(key);
      }

      public Builder clearConst() {
        copyOnWrite();
        instance.getMutableConstMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */

      public Builder removeConst(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableConstMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getConstMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getConst() {
        return getConstMap();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getConstMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getConstMap());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getConstOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getConstMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getConstOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getConstMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */
      public Builder putConst(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableConstMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; const = 2;</code>
       */
      public Builder putAllConst(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableConstMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getPrivateCount() {
        return instance.getPrivateMap().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */
      @java.lang.Override

      public boolean containsPrivate(
          java.lang.String key) {
        key.getClass();
        return instance.getPrivateMap().containsKey(key);
      }

      public Builder clearPrivate() {
        copyOnWrite();
        instance.getMutablePrivateMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */

      public Builder removePrivate(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutablePrivateMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getPrivateMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getPrivate() {
        return getPrivateMap();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getPrivateMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getPrivateMap());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPrivateOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getPrivateMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPrivateOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getPrivateMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */
      public Builder putPrivate(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutablePrivateMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; private = 3;</code>
       */
      public Builder putAllPrivate(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutablePrivateMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getClass_Count() {
        return instance.getClass_Map().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */
      @java.lang.Override

      public boolean containsClass_(
          java.lang.String key) {
        key.getClass();
        return instance.getClass_Map().containsKey(key);
      }

      public Builder clearClass_() {
        copyOnWrite();
        instance.getMutableClass_Map().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */

      public Builder removeClass_(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableClass_Map().remove(key);
        return this;
      }
      /**
       * Use {@link #getClass_Map()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getClass_() {
        return getClass_Map();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getClass_Map() {
        return java.util.Collections.unmodifiableMap(
            instance.getClass_Map());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getClass_OrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getClass_Map();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getClass_OrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getClass_Map();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */
      public Builder putClass_(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableClass_Map().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; class = 4;</code>
       */
      public Builder putAllClass_(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableClass_Map().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getIntCount() {
        return instance.getIntMap().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */
      @java.lang.Override

      public boolean containsInt(
          java.lang.String key) {
        key.getClass();
        return instance.getIntMap().containsKey(key);
      }

      public Builder clearInt() {
        copyOnWrite();
        instance.getMutableIntMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */

      public Builder removeInt(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableIntMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getIntMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getInt() {
        return getIntMap();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getIntMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getIntMap());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIntOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getIntMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getIntOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getIntMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */
      public Builder putInt(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableIntMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; int = 5;</code>
       */
      public Builder putAllInt(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableIntMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getVoidCount() {
        return instance.getVoidMap().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */
      @java.lang.Override

      public boolean containsVoid(
          java.lang.String key) {
        key.getClass();
        return instance.getVoidMap().containsKey(key);
      }

      public Builder clearVoid() {
        copyOnWrite();
        instance.getMutableVoidMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */

      public Builder removeVoid(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableVoidMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getVoidMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getVoid() {
        return getVoidMap();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getVoidMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getVoidMap());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getVoidOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getVoidMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getVoidOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getVoidMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */
      public Builder putVoid(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableVoidMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; void = 6;</code>
       */
      public Builder putAllVoid(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableVoidMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getStringCount() {
        return instance.getStringMap().size();
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */
      @java.lang.Override

      public boolean containsString(
          java.lang.String key) {
        key.getClass();
        return instance.getStringMap().containsKey(key);
      }

      public Builder clearString() {
        copyOnWrite();
        instance.getMutableStringMap().clear();
        return this;
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */

      public Builder removeString(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableStringMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getStringMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getString() {
        return getStringMap();
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getStringMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getStringMap());
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getStringOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getStringMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getStringOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getStringMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */
      public Builder putString(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableStringMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * These are also proto keywords
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; string = 7;</code>
       */
      public Builder putAllString(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableStringMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getPackageCount() {
        return instance.getPackageMap().size();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */
      @java.lang.Override

      public boolean containsPackage(
          java.lang.String key) {
        key.getClass();
        return instance.getPackageMap().containsKey(key);
      }

      public Builder clearPackage() {
        copyOnWrite();
        instance.getMutablePackageMap().clear();
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */

      public Builder removePackage(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutablePackageMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getPackageMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getPackage() {
        return getPackageMap();
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getPackageMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getPackageMap());
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPackageOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getPackageMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getPackageOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getPackageMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */
      public Builder putPackage(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutablePackageMap().put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; package = 8;</code>
       */
      public Builder putAllPackage(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutablePackageMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getEnumCount() {
        return instance.getEnumMap().size();
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */
      @java.lang.Override

      public boolean containsEnum(
          java.lang.String key) {
        key.getClass();
        return instance.getEnumMap().containsKey(key);
      }

      public Builder clearEnum() {
        copyOnWrite();
        instance.getMutableEnumMap().clear();
        return this;
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */

      public Builder removeEnum(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableEnumMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getEnumMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getEnum() {
        return getEnumMap();
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getEnumMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getEnumMap());
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getEnumOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getEnumMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getEnumOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getEnumMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */
      public Builder putEnum(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableEnumMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Most recent Java reserved word
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; enum = 9;</code>
       */
      public Builder putAllEnum(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableEnumMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getNullCount() {
        return instance.getNullMap().size();
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */
      @java.lang.Override

      public boolean containsNull(
          java.lang.String key) {
        key.getClass();
        return instance.getNullMap().containsKey(key);
      }

      public Builder clearNull() {
        copyOnWrite();
        instance.getMutableNullMap().clear();
        return this;
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */

      public Builder removeNull(
          java.lang.String key) {
        key.getClass();
        copyOnWrite();
        instance.getMutableNullMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getNullMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getNull() {
        return getNullMap();
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum>
      getNullMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getNullMap());
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getNullOrDefault(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum defaultValue) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getNullMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */
      @java.lang.Override

      public map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum getNullOrThrow(
          java.lang.String key) {
        key.getClass();
        java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> map =
            instance.getNullMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */
      public Builder putNull(
          java.lang.String key,
          map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum value) {
        key.getClass();
        value.getClass();
        copyOnWrite();
        instance.getMutableNullMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * null is not a 'reserved word' per se but as a literal needs similar care
       * </pre>
       *
       * <code>map&lt;string, .map_for_proto2_test.ReservedAsMapFieldWithEnumValue.SampleEnum&gt; null = 10;</code>
       */
      public Builder putAllNull(
          java.util.Map<java.lang.String, map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum> values) {
        copyOnWrite();
        instance.getMutableNullMap().putAll(values);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:map_for_proto2_test.ReservedAsMapFieldWithEnumValue)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "if_",
              IfDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "const_",
              ConstDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "private_",
              PrivateDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "class__",
              Class_DefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "int_",
              IntDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "void_",
              VoidDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "string_",
              StringDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "package_",
              PackageDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "enum_",
              EnumDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
              "null_",
              NullDefaultEntryHolder.defaultEntry,
              map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.SampleEnum.internalGetVerifier(),
            };
            java.lang.String info =
                "\u0001\n\u0000\u0000\u0001\n\n\n\u0000\u0000\u0001\u0832\u0002\u0832\u0003\u0832" +
                "\u0004\u0832\u0005\u0832\u0006\u0832\u0007\u0832\b\u0832\t\u0832\n\u0832";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue> parser = PARSER;
          if (parser == null) {
            synchronized (map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:map_for_proto2_test.ReservedAsMapFieldWithEnumValue)
    private static final map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue DEFAULT_INSTANCE;
    static {
      ReservedAsMapFieldWithEnumValue defaultInstance = new ReservedAsMapFieldWithEnumValue();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ReservedAsMapFieldWithEnumValue.class, defaultInstance);
    }

    public static map_test.MapForProto2TestProto.ReservedAsMapFieldWithEnumValue getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ReservedAsMapFieldWithEnumValue> PARSER;

    public static com.google.protobuf.Parser<ReservedAsMapFieldWithEnumValue> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
